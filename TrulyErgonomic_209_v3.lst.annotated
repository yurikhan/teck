;; -*- mode: Asm; indent-tabs-mode: nil; comment-column: 48; tab-width: 4 -*-
;;
;; Data variables
;; ==============
;;
;; Ports:
;;   B1 P3.1 DIP switch 4
;;   B2 P3.2 DIP switch 3
;;   B5 P3.5 Num Lock
;;   B6 P3.6 Caps Lock
;;   B7 P3.7 Scroll Lock
;;   E9 P4.1 DIP switch 2
;;   EA P4.2 DIP switch 1
;;
;; RAM:
;;   00 register bank 0
;;   08 register bank 1
;;   10 register bank 2
;;   18 register bank 3
;;   20 byte led_state;
;;      Used in do_receive(), zeroed in init_vars()
;;      Used in upd_leds() as [? ? ? ? ? Scroll Caps ?] bit mask
;;      Bit 0 used in numlock_on() in connection with NumLock
;;   21 enum { KBMODE_NORMAL = 0x5A, KBMODE_MACRO = 0xA5 } kb_mode
;;      Used in upd_leds(), assigned in init_vars(), used in decode_fn(), complemented in process_shift_f12()
;;      // num_lock_fn_lock?
;;   22 byte shift_f12_count;
;;      Zeroed in init_vars(), incremented/tested/zeroed in process_shift_f12()
;;   23 byte column_index;
;;      Zeroed in init_vars(), used in scan_column(), used in same_column_value() as column index,
;;      used in process_key()
;;   24 byte column_value;
;;      Assigned column value in scan_column(), used in two_bits_set()
;;   25 union {
;;      byte new_column_value;
;;          Assigned in read_column()
;;      byte old_column_value;
;;          Assigned in scan_column(), used in decode_fn()
;;      byte column_changed;
;;          Assigned in decode_fn()
;;   26 \ byte key_matrix[18];
;;   37 / Zeroed in init_vars(), used in scan_column(), current/old state of key matrix?
;;   38 bool usb1_transmitting;
;;      Zeroed in init_vars(), zeroed in do_usb_2() when transmission to endpoint 1 is finished,
;;      assigned/waited in process_key()
;;   39 byte idle_rate;
;;      Transmitted in response to vendor request 2, assigned from vendor request 0x0A, never used
;;   3A byte protocol;
;;      Transmitted in response to vendor request 3, assigned from vendor request 0x0B, never used
;;   3B local in decode_numlock(), decode_fn()
;;   3C byte keycode;
;;      assigned/used in decode_fn(), decode_numlock();
;;      assigned in find_macro(); used in store_key()
;;   3D bool phantom;
;;      Zeroed in init_vars(), scan_column(), used/zeroed in process_key()
;;   3E bool normal_key;
;;      Zeroed in init_vars(), assigned in decode_fn(), used/zeroed in process_key(), tested in trigger_numlock()
;;      Zeroed in process_key at end of scanning cycle
;;   3F local in find_macro()
;;   40 byte macro_delay_after;
;;      Tested in play_macro(), assigned in find_macro()
;;   41 \ word macro_delay;
;;   42 / Assigned found->items[j].delay in play_macro()
;;   43 byte usb_intr_count;
;;      Decremented in do_usb_2()
;;   44 bool after_macro;
;;      Tested 0x80/zeroed in process_key(); assigned found->items[j].flags in play_macro()
;;   45 bool usb2_transmitting;
;;      Zeroed in init_vars(), zeroed in do_usb_2() when transmission to endpoint 2 is finished
;;   46 bool media_report_ready;
;;      Assigned in decode_fn(), stop_fn(); tested/zeroed in process_key()
;;   47 byte media_keycode;
;;      Zeroed in init_vars(), used in decode_fn() as Fn-pretranslated keycode, zeroed in stop_fn(),
;;      used in process_fn() as switch
;;   48 \ byte hid_report2[2];
;;   49 / Assigned in process_fn(), stop_fn(), transmitted in process_key()
;;   4A byte keydown_index;
;;      Zeroed in init_vars(), process_key(); loop count in process_key();
;;      tested/incremented in store_key()
;;   4B union {
;;         byte hid_report[8];
;;         struct {
;;             byte key_modifiers;
;;                 bits: [RWin RAlt RShift RCtrl LWin LAlt LShift LCtrl]
;;                 used in process_shift_f12(), process_key()
;;   4C        byte hid_reserved;
;;   4D        byte keys_down[6];
;;   52 }  }
;;      Zeroed in init_vars(), process_key() after transmitting, assigned in process_key().
;;      keys_down[0] == 0xDF in decode_fn() when Fn is down.
;;      keys_down[0] == keys_down[1] == 0 in decode_fn() stops Fn.
;;      keys_down[0], keys_down[1] used in process_shift_f12()
;;      keys_down[0], keys_down[1], keys_down[2] tested/assigned in process_key()
;;   53 local loop counters in two_bits_set(), same_column_value(), decode_fn(),
;;      decode_numlock(), process_key(), find_macro(), play_macro()
;;   54 local loop counters in find_macro(), play_macro()
;;   55 locals in play_macro(), process_key()
;;   56 locals in scan_column(), two_bits_set(), same_column_value(), decode_fn(),
;;      find_macro(), play_macro()
;;   57 \ struct MacroBinding* pBinding
;;   58 / scans memory in find_macro(); corrupted in play_macro() for no reason
;;   59 \ union { MacroData* pMacro; MacroEvent* pMacroEvent; }
;;   5A / Assigned in find_macro() to found->pointer, used in play_macro()
;;   5B \ hardware stack
;;   7F / 37 bytes
;;   :
;;   BC \ byte clockA[18];
;;   CD /
;;   CE \ byte clockB[18];
;;   DF /
;;   E0 \ struct PressedKey { byte keyindex; byte layer; } pressed_keys[15];
;;   FD /
;;
;; XRAM:
;;   0000 byte delay_count;
;;        Decremented by timer0(). timer0() fires every 1000*12 clocks which means 1ms at 12MHz.
;;        initialized and waited for 0 by delay()
;;   0001 byte wdtcr;
;;        Used in timer0(), usb_intr(), keypad()
;;   0003 byte fn_down; // 0x80 if down, 0 if up
;;        Zeroed in init_vars(), assigned/used in process_key()
;;   0004 byte numlock_timer;
;;   0005 byte numlock_state;
;;        Zeroed in int_vars()
;;        Transition from 0x00 to 0xEA in trigger_numlock() if internal numlock is on and a key is pressed
;;        Transition from 0xEA to 0xCC in numlock_on() if internal numlock is on, external off, turning external numlock on
;;        Transition from 0xCC to 0x88 in process_key() if all keys are released, setting timer to 0xFF
;;        Transition from 0x88 to 0xBB in do_delay() when timer expires
;;        Transition from 0xBB to 0x00 in numlock_off(), toggling external numlock [off unless interfered with externally]
;;   0007 byte media_key_down;
;;        Zeroed in init_vars(), used in decode_fn()
;;   000A byte isp_state;
;;        Zeroed in init_isp()
;;        Transition without check from 0x00 to the type of current request in isp_reprogram() called from do_receive()
;;        Value 0x44 in do_transmit() triggers soft reboot
;;        Transition from 0x55 to 0x00 in isp_read_block() sending report 55 AA 00 28 // version check?
;;        In state 0x66 in isp_read_block() read 64 bytes from code/constant memory, prepare for transmitting
;;        Transition from 0x66 to 0x00 in isp_read_block() when isp_count == 0
;;        Transition from any to 0x00 in isp_reprogram() when localX65 >= isp_count resetting localX65 to isp_count (isp_count becomes 0 shortly after)
;;   000B \ byte* isp_ptr;
;;   000C |
;;   000D | Address for ISP read/write operation in isp(), zeroed in init_isp()
;;   000E /
;;   000F \ dword isp_count;
;;   0010 | Count of pages for isp_erase_pages()
;;   0011 | Count of bytes in isp_reprogram() case 0x66 (read macros), 0x77 (erase and write macros)
;;   0012 / Zeroed in init_isp()
;;   0013 local loop counts in isp_reprogram(), isp_erase_pages(), isp_read_block()
;;   0014 bool remote_wakeup;
;;        Used in get_status(), clear_feature(), set_feature(), do_usb_2(), zeroed in init_hw()
;;   0015 bool configured;
;;        Used in do_usb_2(), assigned in set_configuration(), zeroed in init_hw(),
;;        used in process_key()
;;   0016 byte request_state;
;;        Transition to 0xF0 in do_receive() on overwrite
;;        Transition from 0xF0 to 0x5A on short GET requests
;;        Transition from 0xF0 to 0xA5 on short SET requests
;;        Transition from 0xF0 to 0x55 on set_address request
;;        Transition from 0xF0 to 0x22 on get_macros request
;;        Transition from 0xF0 to 0x33 on set_macros request
;;        Transition from 0x33 to 0xA5 after set_macros done
;;   0017 union {
;;         struct Report report;
;;         struct Request request = {
;;             byte bmRequestType;
;;   0018      byte bRequest;
;;   0019      __low_endian word wValue;
;;   001A
;;   001B      __low_endian word wIndex;
;;   001C
;;   001D      __low_endian word wLength;
;;   001E
;;   :
;;   0056 }}
;;   0057 enum AddressingMode {
;;             RAM_8 = 0,
;;             XRAM_16 = 1,
;;             XRAM_8 = 0xFE,
;;             CMEM_16 // all other values; 0xFF used explicitly
;;        } transmit_addr_mode;
;;   0058 \ byte* to_transmit;
;;   0059 /
;;   005B byte max_transmit;
;;        Used in do_transmit(), assigned 0x40 in init_hw()
;;   005C \ word tx_rx_count
;;   005D / Byte count in do_receive(), vendor_request(), do_transmit(), get_status(),
;;          assigned by get_descriptor(), get_interface()
;;   005E union { byte usb_address; byte usb_configuration; } // minor wtf
;;        Assigned in set_configuration(), set_address request
;;   005F \ word requested_size
;;   0060 / Assigned in get_descriptor()
;;   0063 local working copy of UPCON and UIFLG in do_usb_2()
;;   0064 local counts in do_receive(), do_transmit(); local word-sized response size in get_descriptor()
;;   0065 local copy of addressing mode in receive(), transmit()
;;        local copy of size argument in isp_reprogram()
;;   0066 \ local copy of base address argument in receive(), transmit()
;;   0067 /
;;   023F XRAMTOP
;;
;;
;; Const section:
;;
;;   2800 struct Macros macros = {
;;             byte disabled[0x20];
;;        Bit array, each bit corresponding to a keycode. A 0 indicates that for this keycode
;;        a corresponding array of macros is present
;;   2820      byte binding_count;
;;   2821      MacroBinding bindings[binding_count];
;;   ????      byte data[];
;;        };
;;
;; struct MacroBinding {
;;     byte keycode;   // Structures with same keycode go contiguously
;;     byte modifiers; // [0 0 0 0 0 Alt Shift Ctrl]
;;     MacroData* pItems;
;;     bool delay_after;   // if 0, exits immediately after playing;
;;                         // otherwise, after 100 interrupts or when any key is pressed
;; };
;;
;; struct {
;;     00: byte count;
;;     01: struct MacroEvent {
;;             00: byte hid_report[8];
;;             08: word delay:12;
;;             09: byte flags:4;
;;                 0x80 Send an empty report after this (release all keys)
;;                 0x40 ?
;;                 0x20 ?
;;                 0x10 ?
;;         } items[];
;; } MacroData;
;;
;;
;; Code
;; ====
;;
CSEG AT 0000h
  0000 021B31           LJMP START

;;; free 10 bytes

CSEG AT 000Bh
  000B 021A14           LJMP DO_TIMER0

get_status:                                     ;void get_status() {
  000E 785C             MOV R0, #5Ch
  0010 E4               CLR A
  0011 F2               MOVX @R0, A
  0012 08               INC R0
  0013 7402             MOV A, #2h
  0015 F2               MOVX @R0, A             ;   tx_rx_count = 2;
  0016 E4               CLR A
  0017 7818             MOV R0, #18h
  0019 F2               MOVX @R0, A             ;   report[1] = 0;
  001A 18               DEC R0
  001B E2               MOVX A, @R0
  001C 5403             ANL A, #3h              ;   switch (request.bmRequestType & 3) { // Recipient
  001E 14               DEC A
  001F 6043             JZ L0337                ;       // case 1
  0021 14               DEC A
  0022 6014             JZ L0338                ;       // case 2
  0024 2402             ADD A, #2h
  0026 7035             JNZ L0339               ;   case 0: // Device
  0028 7814             MOV R0, #14h
  002A E2               MOVX A, @R0
  002B 6006             JZ L0340                ;       if (remote_wakeup != 0) {
  002D 7817             MOV R0, #17h
  002F 7402             MOV A, #2h
  0031 F2               MOVX @R0, A             ;           report[0] = 2; // Remote wakeup
  0032 22               RET
L0340:                                          ;       } else {
  0033 E4               CLR A
  0034 7817             MOV R0, #17h
  0036 F2               MOVX @R0, A             ;           report[0] = 0;
  0037 22               RET                     ;       }
                                                ;       break;

L0338:                                          ;   case 2: // Endpoint
  0038 781B             MOV R0, #1Bh
  003A E2               MOVX A, @R0
  003B 540F             ANL A, #0Fh
  003D 90FFF1           MOV DPTR, #0FFF1h
  0040 F0               MOVX @DPTR, A           ;       EPINDEX = LOBYTE(request.wIndex) & 0x0F;
  0041 90FFE1           MOV DPTR, #0FFE1h
  0044 E0               MOVX A, @DPTR
  0045 20E704           JB ACC.7, L0341         ;       if (EPCON.RXSTL
  0048 E0               MOVX A, @DPTR
  0049 30E607           JNB ACC.6, L0342        ;       or EPCON.TXSTL) {
L0341:
  004C 7817             MOV R0, #17h
  004E 7401             MOV A, #1h
  0050 F2               MOVX @R0, A             ;           report[0] = 1;  // Halt
  0051 8004             SJMP L0343

L0342:                                          ;       } else {
  0053 E4               CLR A
  0054 7817             MOV R0, #17h
  0056 F2               MOVX @R0, A             ;           report[0] = 0;
L0343:                                          ;       }
  0057 90FFF1           MOV DPTR, #0FFF1h
  005A E4               CLR A
  005B F0               MOVX @DPTR, A           ;       EPINDEX = 0;
  005C 22               RET                     ;       break;

L0339:                                          ;   case 3:
  005D 90FFE1           MOV DPTR, #0FFE1h
  0060 E0               MOVX A, @DPTR
  0061 44C0             ORL A, #0C0h
  0063 F0               MOVX @DPTR, A           ;       EPCON.RXSTL = EPCON.TXSTL = 0;
                                                ;       // fallthrough
L0337:                                          ;   case 1:
  0064 22               RET                     ;}  }

set_ISPCR:                                      ;void set_ISPCR(byte __register(R7) value) {
  0065 8FE7             MOV 0E7h, R7            ;   ISPCR = value;
  0067 22               RET                     ;}

CSEG AT 006Bh
  006B 02164C           LJMP DO_KEYPAD

init_all:                                       ;void init_all() {
  006E 1215E4           LCALL init_interrupts   ;   init_interrupts();
  0071 121AC6           LCALL init_isp          ;   init_isp();
  0074 12177E           LCALL init_vars         ;   init_vars();
  0077 021805           LJMP init_hw            ;   init_hw();
                                                ;}
CSEG AT 007Bh
  007B 021A57           LJMP DO_USB

process_key:                                    ;void process_key() {
  007E 7815             MOV R0, #15h
  0080 E2               MOVX A, @R0
  0081 7003             JNZ L0021               ;   if (configured) {
  0083 02043C           LJMP L0022
L0021:
  0086 7823             MOV R0, #23h
  0088 E6               MOV A, @R0
  0089 6412             XRL A, #12h
  008B 6003             JZ L0023                ;       if (column_index == sizeof(key_matrix)) {
  008D 0203E0           LJMP L0024
L0023:
  0090 783D             MOV R0, #3Dh
  0092 E6               MOV A, @R0
  0093 6052             JZ L0037                ;           if (phantom) {
  0095 E4               CLR A
  0096 784B             MOV R0, #4Bh
  0098 F6               MOV @R0, A              ;               key_modifiers = 0;
  0099 08               INC R0
  009A F6               MOV @R0, A              ;               hid_reserved = 0;
  009B 08               INC R0
  009C 7601             MOV @R0, #1h            ;               keys_down[0] = 1;
  009E 08               INC R0
  009F 7601             MOV @R0, #1h            ;               keys_down[1] = 1;
  00A1 08               INC R0
  00A2 7601             MOV @R0, #1h            ;               keys_down[2] = 1;
  00A4 08               INC R0
  00A5 7601             MOV @R0, #1h            ;               keys_down[3] = 1;
  00A7 08               INC R0
  00A8 7601             MOV @R0, #1h            ;               keys_down[4] = 1;
  00AA 08               INC R0
  00AB 7601             MOV @R0, #1h            ;               keys_down[5] = 1;
  00AD C2AF             CLR EA                  ;               __uninterrupted {
  00AF 90FFF1           MOV DPTR, #0FFF1h
  00B2 04               INC A
  00B3 F0               MOVX @DPTR, A           ;                   EPINDEX = 1;
  00B4 E4               CLR A
  00B5 08               INC R0
  00B6 F6               MOV @R0, A
L0038:                                          ;                   for (byte __volatile(v53) i = 0; i != 8; ++i) {
  00B7 7853             MOV R0, #53h
  00B9 E6               MOV A, @R0
  00BA 244B             ADD A, #4Bh
  00BC F8               MOV R0, A
  00BD E6               MOV A, @R0
  00BE 90FFF3           MOV DPTR, #0FFF3h
  00C1 F0               MOVX @DPTR, A           ;                       TXDAT = hid_report[i];
  00C2 7853             MOV R0, #53h
  00C4 06               INC @R0
  00C5 E6               MOV A, @R0
  00C6 B408EE           CJNE A, #8h, L0038      ;                   }
  00C9 7838             MOV R0, #38h
  00CB 7601             MOV @R0, #1h            ;                   usb1_transmitting = 1;
  00CD 7853             MOV R0, #53h
  00CF E6               MOV A, @R0
  00D0 90FFF6           MOV DPTR, #0FFF6h
  00D3 F0               MOVX @DPTR, A           ;                   TXCNT = i; // 8
  00D4 90FFF1           MOV DPTR, #0FFF1h
  00D7 E4               CLR A
  00D8 F0               MOVX @DPTR, A           ;                   EPINDEX = 0;
  00D9 D2AF             SETB EA                 ;               }
L0042:                                          ;               do {
  00DB 7838             MOV R0, #38h
  00DD E6               MOV A, @R0
  00DE 6401             XRL A, #1h
  00E0 6003             JZ L0039                ;               } while (usb1_transmitting == 1);
  00E2 0203E0           LJMP L0024

L0039:
  00E5 80F4             SJMP L0042

L0037:                                          ;           } else // not phantom
  00E7 783E             MOV R0, #3Eh
  00E9 E6               MOV A, @R0
  00EA 7003             JNZ L0043               ;           if (normal_key) {
  00EC 0203E0           LJMP L0024

L0043:
  00EF 12191E           LCALL process_shift_f12 ;               process_shift_f12();
  00F2 7821             MOV R0, #21h
  00F4 E6               MOV A, @R0
  00F5 645A             XRL A, #5Ah
  00F7 6003             JZ L0045                ;               if (kb_mode == KBMODE_NORMAL) {
  00F9 02030C           LJMP L0046

L0045:
  00FC 02027B           LJMP L9800

;;; 288 bytes free

CSEG AT 021Fh
;;; 41 bytes code
;;; in: keyindex [0..144)
;;; in: layer [0..64)
;;; out: keycode [0..255]
;;; Layer is encoded as a bit mask: ddddnf
;;; where:
;;; * f is the Fn state (0 up, 1 down)
;;; * n is the Internal NumLock state (0 off, 1 on)
;;; * dddd is the state of all DIP switches 1−4, 1 being the high-order bit
;;; This does not mean we have 64 keycode tables;
;;; * If Fn is pressed, use the single Fn table: if (layer & 1) result = fn_keycodes[keyindex]; if (result) return result;
;;; * Iif Num Lock is on, use the single Num tables: if (layer & 2) return num_keycodes[keyindex]; if (result) return result;
;;; * Use the specified Main table: return main_keycodes[layer >> 2][keyindex];
;;; (if only we can place all main tables contiguously).
;;; One keycode table uses 144 (0x90) bytes, 16 tables = 2304 (0x900);
;;; if placed at 0x1B46 will end at 0x2446, IAP memory starts at 0x2800 — just enough room.
do_get_keycode:                                 ;byte __register(R7) do_get_keycode(byte __register(R7) keyindex, byte __register(A) layer) // B DPTR
                                                ;{
                                                ;   byte __register(R7) result;
  021F 13               RRC A
  0220 500B             JNC do_get_keycode_fn   ;   if (layer & 1) {
  0222 90072B           MOV DPTR, #072Bh
  0225 F5F0             MOV B, A
  0227 EF               MOV A, R7
  0228 93               MOVC A, @A+DPTR         ;       result = fn_keycodes[keyindex]; // A == result
  0229 7022             JNZ do_get_keycode_return ;     if (result) return result;
  022B E5F0             MOV A, B
                                                ;   }
do_get_keycode_fn:
  022D 13               RRC A
  022E 500B             JNC do_get_keycode_num  ;   if (layer & 2) {
  0230 9007BB           MOV DPTR, #07BBh
  0233 F5F0             MOV B, A
  0235 EF               MOV A, R7
  0236 93               MOVC A, @A+DPTR         ;       result = num_keycodes[keyindex]; // A == result
  0237 7014             JNZ do_get_keycode_return ;     if (result) return result;
  0239 E5F0             MOV A, B
                                                ;   }
do_get_keycode_num:
  023B 540F             ANL A, #0Fh
  023D 75F090           MOV B, #90h
  0240 A4               MUL AB
  0241 2446             ADD A, #46h
  0243 F582             MOV DPL, A
  0245 741B             MOV A, #1Bh
  0247 35F0             ADDC A, B
  0249 F583             MOV DPH, A
  024B EF               MOV A, R7
  024C 93               MOVC A, @A+DPTR         ;   result = main_keycodes[layer >> 2][keyindex];
do_get_keycode_return:
  024D FF               MOV R7, A
  024E 22               RET                     ;   return result;
                                                ;}
;;; 50 bytes free
CSEG AT 027Bh
L9800:
  027B 784D             MOV R0, #4Dh
  027D E6               MOV A, @R0
  027E B4AD04           CJNE A, #0ADh, L9401    ;                   if (keys_down[0] == 0xAD) { // WinBrk
  0281 7480             MOV A, #80h
  0283 8005             SJMP L9402              ;                       key_modifiers.RWin = true;
                                                ;                       keys_down[0] = 0x48; // Pause
                                                ;                   } else
L9401:
  0285 B4AE0A           CJNE A, #0AEh, L0104    ;                   if (keys_down[0] == 0xAE) { // CtrlBrk
  0288 7410             MOV A, #10h
L9402:
  028A 784B             MOV R0, #4Bh
  028C 46               ORL A, @R0
  028D F6               MOV @R0, A              ;                       key_modifiers.RCtrl = true;
  028E 784D             MOV R0, #4Dh
  0290 7648             MOV @R0, #48h           ;                       keys_down[0] = 0x48; // Pause
L0104:                                          ;                   }
  0292 121502           LCALL numlock_on        ;                   numlock_on();
  0295 7805             MOV R0, #5h
  0297 E2               MOVX A, @R0
  0298 B48807           CJNE A, #88h, L0115     ;                   if (numlock_state == 0x88) {
  029B E4               CLR A
  029C 18               DEC R0
  029D F2               MOVX @R0, A             ;                       numlock_timer = 0;
  029E 08               INC R0
  029F 74CC             MOV A, #0CCh
  02A1 F2               MOVX @R0, A             ;                       numlock_state = 0xCC;
L0115:                                          ;                   }
  02A2 C2AF             CLR EA                  ;                   __uninterrupted {
  02A4 90FFF1           MOV DPTR, #0FFF1h
  02A7 7401             MOV A, #1h
  02A9 F0               MOVX @DPTR, A           ;                       EPINDEX = 1;
  02AA E4               CLR A
  02AB 7853             MOV R0, #53h
  02AD F6               MOV @R0, A
L0116:                                          ;                       for (byte __volatile(v53) i = 0; i != 8; ++i) {
  02AE 7853             MOV R0, #53h
  02B0 E6               MOV A, @R0
  02B1 244B             ADD A, #4Bh
  02B3 F8               MOV R0, A
  02B4 E6               MOV A, @R0
  02B5 90FFF3           MOV DPTR, #0FFF3h
  02B8 F0               MOVX @DPTR, A           ;                           TXDAT = hid_report[i];
  02B9 7853             MOV R0, #53h
  02BB 06               INC @R0
  02BC E6               MOV A, @R0
  02BD B408EE           CJNE A, #8h, L0116      ;                       }
  02C0 7838             MOV R0, #38h
  02C2 7601             MOV @R0, #1h            ;                       usb1_transmitting = 1;
  02C4 7853             MOV R0, #53h
  02C6 E6               MOV A, @R0
  02C7 90FFF6           MOV DPTR, #0FFF6h
  02CA F0               MOVX @DPTR, A           ;                       TXCNT = i; // 8
  02CB 90FFF1           MOV DPTR, #0FFF1h
  02CE E4               CLR A
  02CF F0               MOVX @DPTR, A           ;                       EPINDEX = 0;
  02D0 D2AF             SETB EA                 ;                   }
L0117:                                          ;                   do {
  02D2 7838             MOV R0, #38h
  02D4 E6               MOV A, @R0
  02D5 6401             XRL A, #1h
  02D7 60F9             JZ L0117                ;                   } while (usb1_transmitting == 1);
  02D9 784B             MOV R0, #4Bh
  02DB E6               MOV A, @R0
  02DC 6003             JZ L0118                ;                   if (key_modifiers == 0
  02DE 0203E0           LJMP L0024
L0118:
  02E1 784D             MOV R0, #4Dh
  02E3 E6               MOV A, @R0
  02E4 6003             JZ L0119                ;                       and keys_down[0] == 0
  02E6 0203E0           LJMP L0024
L0119:
  02E9 08               INC R0
  02EA E6               MOV A, @R0
  02EB 6003             JZ L0120                ;                       and keys_down[1] == 0
  02ED 0203E0           LJMP L0024
L0120:
  02F0 7804             MOV R0, #4h
  02F2 E2               MOVX A, @R0
  02F3 6003             JZ L0121                ;                       and numlock_timer == 0
  02F5 0203E0           LJMP L0024
L0121:
  02F8 08               INC R0
  02F9 E2               MOVX A, @R0
  02FA 64CC             XRL A, #0CCh
  02FC 6003             JZ L0122                ;                       and numlock_state == 0xCC)
  02FE 0203E0           LJMP L0024
L0122:                                          ;                   {
  0301 18               DEC R0
  0302 74FF             MOV A, #0FFh
  0304 F2               MOVX @R0, A             ;                       numlock_timer = 0xFF;
  0305 08               INC R0
  0306 7488             MOV A, #88h
  0308 F2               MOVX @R0, A             ;                       numlock_state = 0x88;
  0309 0203E0           LJMP L0024
                                                ;                   }
L0046:                                          ;               } else /*kb_mode != 0x5A*/
  030C 7844             MOV R0, #44h
  030E E6               MOV A, @R0
  030F B48010           CJNE A, #80h, L0047     ;               if (after_macro == 0x80
  0312 784B             MOV R0, #4Bh
  0314 E6               MOV A, @R0
  0315 700B             JNZ L0047               ;                   and key_modifiers == 0
  0317 784D             MOV R0, #4Dh
  0319 E6               MOV A, @R0
  031A 7006             JNZ L0047               ;                   and keys_down[0] == 0)
  031C 7844             MOV R0, #44h            ;               {
  031E F6               MOV @R0, A              ;                   after_macro = 0;
  031F 0203E0           LJMP L0024
L0047:                                          ;               } else {
  0322 E4               CLR A
  0323 784A             MOV R0, #4Ah
  0325 F6               MOV @R0, A
L0054:                                          ;                   for (keydown_index = 0; keydown_index < 6 and keys_down[keydown_index]; ) {
  0326 784A             MOV R0, #4Ah
  0328 E6               MOV A, @R0
  0329 C3               CLR C
  032A 9406             SUBB A, #6h
  032C 4003             JC L0048
  032E 0203E0           LJMP L0024
L0048:
  0331 120B69           LCALL find_macro        ;                       if (find_macro(&keydown_index)) {
  0334 500C             JNC L0050
  0336 12043D           LCALL play_macro        ;                           play_macro();
  0339 784A             MOV R0, #4Ah
  033B 06               INC @R0                 ;                           ++keydown_index;
  033C 7844             MOV R0, #44h
  033E 7680             MOV @R0, #80h           ;                           after_macro = 0x80;
  0340 805D             SJMP L0052              ;                           continue;

L0050:                                          ;                       }
  0342 E4               CLR A
  0343 7844             MOV R0, #44h
  0345 F6               MOV @R0, A              ;                       after_macro = 0;
  0346 C2AF             CLR EA                  ;                       __uninterrupted {
  0348 90FFF1           MOV DPTR, #0FFF1h
  034B 04               INC A
  034C F0               MOVX @DPTR, A           ;                           EPINDEX = 1;
  034D 784B             MOV R0, #4Bh
  034F E6               MOV A, @R0
  0350 90FFF3           MOV DPTR, #0FFF3h
  0353 F0               MOVX @DPTR, A           ;                           TXDAT = key_modifiers;
  0354 08               INC R0
  0355 E6               MOV A, @R0
  0356 F0               MOVX @DPTR, A           ;                           TXDAT = hid_reserved;
  0357 E4               CLR A
  0358 7855             MOV R0, #55h
  035A F6               MOV @R0, A
L0081:                                          ;                           for (byte __volatile(v55) k = 0; j < 6 and not find_macro(keydown_index); ++keydown_index, ++k) {
  035B 784A             MOV R0, #4Ah
  035D E6               MOV A, @R0
  035E C3               CLR C
  035F 9406             SUBB A, #6h
  0361 5014             JNC L0080
  0363 120B69           LCALL find_macro
  0366 400F             JC L0080
  0368 783C             MOV R0, #3Ch
  036A E6               MOV A, @R0
  036B 90FFF3           MOV DPTR, #0FFF3h
  036E F0               MOVX @DPTR, A           ;                               TXDAT = keycode;
  036F 784A             MOV R0, #4Ah
  0371 06               INC @R0
  0372 7855             MOV R0, #55h
  0374 06               INC @R0
  0375 80E4             SJMP L0081              ;                           }

L0080:                                          ;                           for (; k < 6; ++k) {
  0377 7855             MOV R0, #55h
  0379 E6               MOV A, @R0
  037A C3               CLR C
  037B 9406             SUBB A, #6h
  037D 5008             JNC L0082

  037F 90FFF3           MOV DPTR, #0FFF3h
  0382 E4               CLR A
  0383 F0               MOVX @DPTR, A           ;                               TXDAT = 0;
  0384 06               INC @R0
  0385 80F0             SJMP L0080              ;                           }

L0082:
  0387 7838             MOV R0, #38h
  0389 7601             MOV @R0, #1h            ;                           usb1_transmitting = 1;
  038B 90FFF6           MOV DPTR, #0FFF6h
  038E 7408             MOV A, #8h
  0390 F0               MOVX @DPTR, A           ;                           TXCON = 8;
  0391 90FFF1           MOV DPTR, #0FFF1h
  0394 E4               CLR A
  0395 F0               MOVX @DPTR, A           ;                           EPINDEX = 0;
  0396 D2AF             SETB EA                 ;                       }
L0083:                                          ;                       do {
  0398 7838             MOV R0, #38h
  039A E6               MOV A, @R0
  039B 6401             XRL A, #1h
  039D 60F9             JZ L0083                ;                       } while (usb1_transmitting == 1);
L0052:
  039F 784A             MOV R0, #4Ah
  03A1 E6               MOV A, @R0
  03A2 C3               CLR C
  03A3 9406             SUBB A, #6h
  03A5 4003             JC L0053
  03A7 020326           LJMP L0054

L0053:
  03AA E6               MOV A, @R0
  03AB 244D             ADD A, #4Dh
  03AD F8               MOV R0, A
  03AE E6               MOV A, @R0
  03AF 602F             JZ L0024
  03B1 020326           LJMP L0054              ;                   }
                                                ;           }   }
;;; 44 bytes free
CSEG AT 03E0h
L0024:                                          ;       } // column_index == 0x12
  03E0 7846             MOV R0, #46h
  03E2 E6               MOV A, @R0
  03E3 603B             JZ L0025                ;       if (media_report_ready) {
  03E5 C2AF             CLR EA                  ;           __uninterrupted {
  03E7 90FFF1           MOV DPTR, #0FFF1h
  03EA 7402             MOV A, #2h
  03EC F0               MOVX @DPTR, A           ;               EPINDEX = 2;
  03ED E4               CLR A
  03EE 7853             MOV R0, #53h
  03F0 F6               MOV @R0, A
L0026:                                          ;               for (byte __volatile(v53) i = 0; i != 2; ++i) {
  03F1 7853             MOV R0, #53h
  03F3 E6               MOV A, @R0
  03F4 2448             ADD A, #48h
  03F6 F8               MOV R0, A
  03F7 E6               MOV A, @R0
  03F8 90FFF3           MOV DPTR, #0FFF3h
  03FB F0               MOVX @DPTR, A           ;                   TXDAT = hid_report2[i];
  03FC 7853             MOV R0, #53h
  03FE 06               INC @R0
  03FF E6               MOV A, @R0
  0400 B402EE           CJNE A, #2h, L0026      ;               }
  0403 7845             MOV R0, #45h
  0405 7601             MOV @R0, #1h            ;               usb2_transmitting = 1;
  0407 7853             MOV R0, #53h
  0409 E6               MOV A, @R0
  040A 90FFF6           MOV DPTR, #0FFF6h
  040D F0               MOVX @DPTR, A           ;               TXCNT = i; // 2
  040E 90FFF1           MOV DPTR, #0FFF1h
  0411 E4               CLR A
  0412 F0               MOVX @DPTR, A           ;               EPINDEX = 0;
  0413 D2AF             SETB EA                 ;           }
L0027:                                          ;           do {
  0415 7845             MOV R0, #45h
  0417 E6               MOV A, @R0
  0418 6401             XRL A, #1h
  041A 60F9             JZ L0027                ;           } while (usb2_transmitting == 1);
  041C E4               CLR A
  041D 7846             MOV R0, #46h
  041F F6               MOV @R0, A              ;           media_report_ready = 0;
L0025:                                          ;       }
  0420 7823             MOV R0, #23h
  0422 E6               MOV A, @R0
  0423 B41216           CJNE A, #12h, L0022     ;       if (column_index == sizeof(key_matrix)) {
  0426 E4               CLR A
  0427 784A             MOV R0, #4Ah
  0429 F6               MOV @R0, A              ;           keydown_index = 0;
  042A FE               MOV R6, A
  042B 7F08             MOV R7, #8h
  042D FD               MOV R5, A
  042E FB               MOV R3, A
  042F 7A00             MOV R2, #0h
  0431 794B             MOV R1, #4Bh
  0433 12105C           LCALL memset            ;           memset(hid_report, 8, 0);
  0436 E4               CLR A
  0437 783E             MOV R0, #3Eh
  0439 F6               MOV @R0, A              ;           normal_key = false;
  043A 18               DEC R0
  043B F6               MOV @R0, A              ;           phantom = 0;
L0022:                                          ;   }   }
  043C 22               RET                     ;}

play_macro:                                     ;void play_macro() {
  043D 7859             MOV R0, #59h
  043F E6               MOV A, @R0
  0440 FF               MOV R7, A
  0441 08               INC R0
  0442 E6               MOV A, @R0
  0443 7857             MOV R0, #57h
  0445 0205BB           LJMP L0055
;; ======================================
;; L0055:
;;   05BB CF               XCH A, R7
;;   05BC F6               MOV @R0, A
;;   05BD 08               INC R0
;;   05BE EF               MOV A, R7
;;   05BF F6               MOV @R0, A           ;   vw57 = pMacro;
;;   05C0 020448           LJMP L0056
;; ======================================
L0056:                                          ;   for (;;) {
  0448 7859             MOV R0, #59h
  044A E6               MOV A, @R0
  044B FE               MOV R6, A
  044C 08               INC R0
  044D E6               MOV A, @R0
  044E F582             MOV DPL, A
  0450 8E83             MOV DPH, R6
  0452 E4               CLR A
  0453 93               MOVC A, @A+DPTR
  0454 7855             MOV R0, #55h
  0456 F6               MOV @R0, A              ;       byte __volatile(v55) n = pMacro->count;
  0457 785A             MOV R0, #5Ah
  0459 06               INC @R0
  045A E6               MOV A, @R0
  045B 18               DEC R0
  045C 7001             JNZ L0057
  045E 06               INC @R0                 ;       pMacroEvent = &pMacro->items[0];
L0057:
  045F E4               CLR A
  0460 7856             MOV R0, #56h
  0462 F6               MOV @R0, A              ;       v56 = 0;
  0463 7854             MOV R0, #54h
  0465 F6               MOV @R0, A
L0079:
  0466 7954             MOV R1, #54h
  0468 E7               MOV A, @R1
  0469 C3               CLR C
  046A 7855             MOV R0, #55h
  046C 96               SUBB A, @R0
  046D 4003             JC L0058                ;       for (byte __volatile(v54) j = 0; j < n; ++j) {
  046F 02057A           LJMP L0059

L0058:
  0472 C2AF             CLR EA                  ;           __uninterrupted {
  0474 90FFF1           MOV DPTR, #0FFF1h
  0477 7401             MOV A, #1h
  0479 F0               MOVX @DPTR, A           ;               EPINDEX = 1;
  047A E4               CLR A
  047B 7853             MOV R0, #53h
  047D F6               MOV @R0, A
L0068:                                          ;               for (byte __volatile(v53) i = 0; i < 8; ++i) {
  047E 7853             MOV R0, #53h
  0480 E6               MOV A, @R0
  0481 FF               MOV R7, A
  0482 C3               CLR C
  0483 9408             SUBB A, #8h
  0485 5017             JNC L0067

  0487 EF               MOV A, R7
  0488 785A             MOV R0, #5Ah
  048A 26               ADD A, @R0
  048B FF               MOV R7, A
  048C E4               CLR A
  048D 18               DEC R0
  048E 36               ADDC A, @R0
  048F 8F82             MOV DPL, R7
  0491 F583             MOV DPH, A
  0493 E4               CLR A
  0494 93               MOVC A, @A+DPTR
  0495 90FFF3           MOV DPTR, #0FFF3h
  0498 F0               MOVX @DPTR, A           ;                   TXDAT = pMacroEvent->hid_report[i];
  0499 7853             MOV R0, #53h
  049B 06               INC @R0
  049C 80E0             SJMP L0068              ;               }

L0067:
  049E 7853             MOV R0, #53h
  04A0 E6               MOV A, @R0
  04A1 785A             MOV R0, #5Ah
  04A3 26               ADD A, @R0
  04A4 FF               MOV R7, A
  04A5 E4               CLR A
  04A6 18               DEC R0
  04A7 36               ADDC A, @R0
  04A8 8F82             MOV DPL, R7
  04AA F583             MOV DPH, A
  04AC E4               CLR A
  04AD 93               MOVC A, @A+DPTR
  04AE 7842             MOV R0, #42h
  04B0 F6               MOV @R0, A              ;               LOBYTE(macro_delay) = LOBYTE(pMacroEvent->delay);
  04B1 7853             MOV R0, #53h
  04B3 06               INC @R0                 ;               ++i; // 9
  04B4 E6               MOV A, @R0
  04B5 785A             MOV R0, #5Ah
  04B7 26               ADD A, @R0
  04B8 FF               MOV R7, A
  04B9 E4               CLR A
  04BA 18               DEC R0
  04BB 36               ADDC A, @R0
  04BC 8F82             MOV DPL, R7
  04BE F583             MOV DPH, A
  04C0 E4               CLR A
  04C1 93               MOVC A, @A+DPTR
  04C2 7841             MOV R0, #41h
  04C4 F6               MOV @R0, A              ;               HIBYTE(macro_delay) = HIBYTE(pMacroEvent->delay) | pMacroEvent->flags;
  04C5 E6               MOV A, @R0
  04C6 54F0             ANL A, #0F0h
  04C8 7944             MOV R1, #44h
  04CA F7               MOV @R1, A              ;               after_macro = pMacroEvent.flags;
  04CB E6               MOV A, @R0
  04CC 540F             ANL A, #0Fh
  04CE F6               MOV @R0, A              ;               HIBYTE(macro_delay) = HIBYTE(pMacroEvent->delay);
  04CF 7838             MOV R0, #38h
  04D1 7601             MOV @R0, #1h            ;               usb1_transmitting = 1;

                                                ;               // FIXME:
  04D3 7853             MOV R0, #53h            ;               // 00   NOP
  04D5 E6               MOV A, @R0              ;               // 7408 MOV A, #08h

  04D6 90FFF6           MOV DPTR, #0FFF6h
  04D9 F0               MOVX @DPTR, A           ;               TXCNT = i; // 9??
  04DA 90FFF1           MOV DPTR, #0FFF1h
  04DD E4               CLR A
  04DE F0               MOVX @DPTR, A           ;               EPINDEX = 0;
  04DF D2AF             SETB EA                 ;           }
L0069:                                          ;           do {
  04E1 7838             MOV R0, #38h
  04E3 E6               MOV A, @R0
  04E4 6401             XRL A, #1h
  04E6 60F9             JZ L0069                ;           } while (usb1_transmitting == 1);
  04E8 785A             MOV R0, #5Ah
  04EA 740A             MOV A, #0Ah
  04EC 26               ADD A, @R0
  04ED F6               MOV @R0, A
  04EE 18               DEC R0
  04EF E4               CLR A
  04F0 36               ADDC A, @R0
  04F1 F6               MOV @R0, A              ;           ++pMacroEvent; // to found->items[j+1]
  04F2 7843             MOV R0, #43h
  04F4 7615             MOV @R0, #15h           ;           usb_intr_count = 0x15; // 21
L0070:                                          ;           do {
  04F6 7843             MOV R0, #43h
  04F8 E6               MOV A, @R0
  04F9 70FB             JNZ L0070               ;           } while (usb_intr_count); // wait for 21 USB interrupts?
  04FB 7844             MOV R0, #44h
  04FD E6               MOV A, @R0
  04FE 20E731           JB ACC.7, L0071         ;           if (not after_macro.7) {
  0501 C2AF             CLR EA                  ;               __uninterrupted {
  0503 90FFF1           MOV DPTR, #0FFF1h
  0506 7401             MOV A, #1h
  0508 F0               MOVX @DPTR, A           ;                   EPINDEX = 1;
  0509 E4               CLR A
  050A 7853             MOV R0, #53h
  050C F6               MOV @R0, A
L0072:                                          ;                   for (byte __volatile(v53) i = 0; i != 8; ++i) {
  050D 90FFF3           MOV DPTR, #0FFF3h
  0510 E4               CLR A
  0511 F0               MOVX @DPTR, A           ;                       TXDAT = 0;
  0512 7853             MOV R0, #53h
  0514 06               INC @R0
  0515 E6               MOV A, @R0
  0516 B408F4           CJNE A, #8h, L0072      ;                   }
  0519 7838             MOV R0, #38h
  051B 7601             MOV @R0, #1h            ;                   usb1_transmitting = 1;
  051D 7853             MOV R0, #53h
  051F E6               MOV A, @R0
  0520 90FFF6           MOV DPTR, #0FFF6h
  0523 F0               MOVX @DPTR, A           ;                   TXCNT = i; // 8
  0524 90FFF1           MOV DPTR, #0FFF1h
  0527 E4               CLR A
  0528 F0               MOVX @DPTR, A           ;                   EPINDEX = 0;
  0529 D2AF             SETB EA                 ;               }
L0073:                                          ;               do {
  052B 7838             MOV R0, #38h
  052D E6               MOV A, @R0
  052E 6401             XRL A, #1h
  0530 60F9             JZ L0073                ;               } while (usb1_transmitting == 1);
L0071:                                          ;           } // if after_macro.7
  0532 7842             MOV R0, #42h
  0534 E6               MOV A, @R0
  0535 18               DEC R0
  0536 46               ORL A, @R0
  0537 603B             JZ L0074                ;           if (macro_delay) {
  0539 7843             MOV R0, #43h
  053B 7632             MOV @R0, #32h           ;               usb_intr_count = 0x32; // 50
L0075:                                          ;               do {
  053D 7843             MOV R0, #43h
  053F E6               MOV A, @R0
  0540 70FB             JNZ L0075               ;               } while (usb_intr_count);
  0542 7842             MOV R0, #42h
  0544 E6               MOV A, @R0
  0545 16               DEC @R0
  0546 18               DEC R0
  0547 7001             JNZ L0076
  0549 16               DEC @R0                 ;               --macro_delay;
L0076:
  054A 7842             MOV R0, #42h
  054C E6               MOV A, @R0
  054D 18               DEC R0
  054E 46               ORL A, @R0
  054F 6023             JZ L0074                ;               if (macro_delay) {
  0551 7843             MOV R0, #43h
  0553 7632             MOV @R0, #32h           ;
L0078:                                          ;                   for (usb_intr_count = 0x32 /*50*/; usb_intr_count; ) {
  0555 7843             MOV R0, #43h
  0557 E6               MOV A, @R0
  0558 6010             JZ L0077
  055A 7856             MOV R0, #56h
  055C E6               MOV A, @R0
  055D 70F6             JNZ L0078               ;                       if (v56 == 0)
  055F 7F12             MOV R7, #12h
  0561 12169B           LCALL read_column
  0564 7856             MOV R0, #56h
  0566 EF               MOV A, R7
  0567 F6               MOV @R0, A              ;                           v56 = read_column(sizeof(key_matrix));
  0568 80EB             SJMP L0078              ;                   }

L0077:
  056A 7842             MOV R0, #42h
  056C E6               MOV A, @R0
  056D 16               DEC @R0
  056E 18               DEC R0
  056F 70D9             JNZ L0076
  0571 16               DEC @R0                 ;                   --macro_delay;
  0572 80D6             SJMP L0076

L0074:                                          ;           }   }
  0574 7854             MOV R0, #54h
  0576 06               INC @R0
  0577 020466           LJMP L0079

L0059:                                          ;       } // for j
  057A 7840             MOV R0, #40h
  057C E6               MOV A, @R0
  057D 7002             JNZ L0060               ;       if (macro_delay_after == 0)
  057F D3               SETB C
  0580 22               RET                     ;           return true;

L0060:
  0581 7856             MOV R0, #56h
  0583 E6               MOV A, @R0
  0584 6002             JZ L0061                ;       if (v56 != 0)
  0586 D3               SETB C
  0587 22               RET                     ;           return true;

L0061:
  0588 7843             MOV R0, #43h
  058A 7632             MOV @R0, #32h           ;
L0064:                                          ;       for (usb_intr_count = 0x32 /*50*/; usb_intr_count; ) {
  058C 7843             MOV R0, #43h
  058E E6               MOV A, @R0
  058F 600D             JZ L0062
  0591 7F12             MOV R7, #12h
  0593 12169B           LCALL read_column
  0596 7856             MOV R0, #56h
  0598 EF               MOV A, R7
  0599 F6               MOV @R0, A              ;           v56 = read_column(sizeof(key_matrix));
  059A 60F0             JZ L0064                ;           if (v56)
  059C D3               SETB C
  059D 22               RET                     ;               return true;

L0062:                                          ;       }
  059E 7843             MOV R0, #43h
  05A0 7632             MOV @R0, #32h
L0066:                                          ;       for (usb_intr_count = 0x32 /*50*/; usb_intr_count; ) {
  05A2 7843             MOV R0, #43h
  05A4 E6               MOV A, @R0
  05A5 600D             JZ L0065
  05A7 7F12             MOV R7, #12h
  05A9 12169B           LCALL read_column
  05AC 7856             MOV R0, #56h
  05AE EF               MOV A, R7
  05AF F6               MOV @R0, A              ;           v56 = read_column(sizeof(key_matrix));
  05B0 60F0             JZ L0066                ;           if (v56)
  05B2 D3               SETB C
  05B3 22               RET                     ;               return true;

L0065:                                          ;       }
  05B4 7857             MOV R0, #57h
  05B6 E6               MOV A, @R0
  05B7 FF               MOV R7, A
  05B8 08               INC R0
  05B9 E6               MOV A, @R0
  05BA 08               INC R0
L0055:
  05BB CF               XCH A, R7
  05BC F6               MOV @R0, A
  05BD 08               INC R0
  05BE EF               MOV A, R7
  05BF F6               MOV @R0, A
  05C0 020448           LJMP L0056              ;}  }

get_descriptor:                                 ;void get_descriptor() {
  05C3 E4               CLR A
  05C4 7864             MOV R0, #64h
  05C6 F2               MOVX @R0, A             ;   X64 = 0;
  05C7 781E             MOV R0, #1Eh
  05C9 E2               MOVX A, @R0
  05CA 785F             MOV R0, #5Fh
  05CC F2               MOVX @R0, A
  05CD 781D             MOV R0, #1Dh
  05CF E2               MOVX A, @R0
  05D0 7860             MOV R0, #60h
  05D2 F2               MOVX @R0, A             ;   word requested_size = request.wLength;
  05D3 781A             MOV R0, #1Ah
  05D5 E2               MOVX A, @R0             ;   switch (HIBYTE(request.wValue)) {
  05D6 24FE             ADD A, #0FEh
  05D8 602A             JZ L0362                ;       // case 2
  05DA 14               DEC A
  05DB 6040             JZ L0363                ;       // case 3
  05DD 24E2             ADD A, #0E2h
  05DF 7003             JNZ L0364
  05E1 020698           LJMP L0365              ;       // case 0x21

L0364:
  05E4 14               DEC A
  05E5 7003             JNZ L0374
  05E7 0206C9           LJMP L0375              ;       // case 0x22

L0374:
  05EA 2421             ADD A, #21h
  05EC 6003             JZ L0378                ;       // case 1
  05EE 0206FA           LJMP L0379              ;       // default

L0378:                                          ;   case 1: // Device descriptor
  05F1 7BFF             MOV R3, #0FFh
  05F3 7A13             MOV R2, #13h
  05F5 795B             MOV R1, #5Bh
  05F7 7857             MOV R0, #57h
  05F9 EB               MOV A, R3
  05FA F2               MOVX @R0, A             ;       transmit_addr_mode = CMEM_16;
  05FB 08               INC R0
  05FC EA               MOV A, R2
  05FD F2               MOVX @R0, A
  05FE 08               INC R0
  05FF E9               MOV A, R1
  0600 F2               MOVX @R0, A             ;       to_transmit = &device_descriptor;  // base address
  0601 020693           LJMP L0380              ;       X65 = device_descriptor.bLength; break; // byte count

L0362:                                          ;   case 2: // Configuration descriptor
  0604 7BFF             MOV R3, #0FFh
  0606 7A0D             MOV R2, #0Dh
  0608 79E5             MOV R1, #0E5h
  060A 7857             MOV R0, #57h
  060C EB               MOV A, R3
  060D F2               MOVX @R0, A             ;       transmit_addr_mode = CMEM_16;
  060E 08               INC R0
  060F EA               MOV A, R2
  0610 F2               MOVX @R0, A
  0611 08               INC R0
  0612 E9               MOV A, R1
  0613 F2               MOVX @R0, A             ;       to_transmit = &configuration_descriptor;
  0614 900002           MOV DPTR, #0002h
  0617 120FD7           LCALL memread
  061A 0206C4           LJMP L0381              ;       X65 = configuration_descriptor.wTotalLength; break; // memread(0xFF, 2, 0x0DE5)

L0363:                                          ;   case 3: // String descriptor
  061D 7819             MOV R0, #19h
  061F E2               MOVX A, @R0             ;       switch (LOBYTE(request.wValue)) {
  0620 14               DEC A
  0621 6019             JZ L0382                ;           // case 1
  0623 14               DEC A
  0624 602C             JZ L0383                ;           // case 2
  0626 14               DEC A
  0627 6041             JZ L0384                ;           // case 3
  0629 2403             ADD A, #3h
  062B 7055             JNZ L0385               ;       case 0: // String languages
  062D 7857             MOV R0, #57h
  062F 74FF             MOV A, #0FFh
  0631 F2               MOVX @R0, A             ;           transmit_addr_mode = CMEM_16;
  0632 08               INC R0
  0633 7413             MOV A, #13h
  0635 F2               MOVX @R0, A
  0636 08               INC R0
  0637 746D             MOV A, #6Dh
  0639 F2               MOVX @R0, A             ;           to_transmit = &string_languages;
  063A 804D             SJMP L0386

L0382:                                          ;       case 1: // Manufacturer name
  063C 901369           MOV DPTR, #01369h
  063F E4               CLR A
  0640 93               MOVC A, @A+DPTR
  0641 603F             JZ L0385                ;           if (device_descriptor.iManufacturer == 0) /*false*/ { EPCON.RXSTL = EPCON.TXSTL = 1; break; }
  0643 7857             MOV R0, #57h
  0645 74FF             MOV A, #0FFh
  0647 F2               MOVX @R0, A             ;           transmit_addr_mode = CMEM_16;
  0648 08               INC R0
  0649 7413             MOV A, #13h
  064B F2               MOVX @R0, A
  064C 08               INC R0
  064D 7471             MOV A, #71h
  064F F2               MOVX @R0, A             ;           to_transmit = &manufacturer_name;
  0650 8037             SJMP L0386              ;           break;

L0383:                                          ;       case 2: // Product name
  0652 90136A           MOV DPTR, #0136Ah
  0655 E4               CLR A
  0656 93               MOVC A, @A+DPTR
  0657 600F             JZ L0388                ;           if (device_descriptor.iProduct != 0) { // true
  0659 7857             MOV R0, #57h
  065B 74FF             MOV A, #0FFh
  065D F2               MOVX @R0, A             ;               transmit_addr_mode = CMEM_16;
  065E 08               INC R0
  065F 7413             MOV A, #13h
  0661 F2               MOVX @R0, A
  0662 08               INC R0
  0663 7497             MOV A, #97h
  0665 F2               MOVX @R0, A             ;               to_transmit = &product_name;
  0666 8021             SJMP L0386              ;               break;

L0388:                                          ;           }
  0668 8018             SJMP L0385              ;           EPCON.RXSTL = EPCON.TXSTL = 1; break;

L0384:                                          ;       case 3: // Serial number
  066A 90136B           MOV DPTR, #0136Bh
  066D E4               CLR A
  066E 93               MOVC A, @A+DPTR
  066F 600F             JZ L0387                ;           if (device_descriptor.iSerialNumber != 0) { // false
  0671 7857             MOV R0, #57h
  0673 74FF             MOV A, #0FFh
  0675 F2               MOVX @R0, A             ;               transmit_addr_mode = CMEM_16;
  0676 08               INC R0
  0677 7413             MOV A, #13h
  0679 F2               MOVX @R0, A
  067A 08               INC R0
  067B 74DB             MOV A, #0DBh
  067D F2               MOVX @R0, A             ;               to_transmit = &serial_number;
  067E 8009             SJMP L0386              ;               break;

L0387:                                          ;           }
  0680 8000             SJMP L0385              ;           EPCON.RXSTL = EPCON.TXSTL = 1; break;

L0385:                                          ;       default: // Invalid
  0682 90FFE1           MOV DPTR, #0FFE1h
  0685 E0               MOVX A, @DPTR
  0686 44C0             ORL A, #0C0h
  0688 F0               MOVX @DPTR, A           ;           EPCON.RXSTL = EPCON.TXSTL = 1;
L0386:                                          ;       }
  0689 7857             MOV R0, #57h
  068B E2               MOVX A, @R0
  068C FB               MOV R3, A
  068D 08               INC R0
  068E E2               MOVX A, @R0
  068F FA               MOV R2, A
  0690 08               INC R0
  0691 E2               MOVX A, @R0
  0692 F9               MOV R1, A
L0380:
  0693 120FBE           LCALL byte_read
  0696 802C             SJMP L0381              ;       X65 = *to_transmit; break; // byte_read(transmit_addr_mode, to_transmit)

L0365:                                          ;   case 0x21: // HID descriptor
  0698 781B             MOV R0, #1Bh
  069A E2               MOVX A, @R0
  069B 7857             MOV R0, #57h
  069D 600D             JZ L0366                ;       if (LOBYTE(request.wIndex) != 0) {
  069F 74FF             MOV A, #0FFh
  06A1 F2               MOVX @R0, A             ;           transmit_addr_mode = CMEM_16;
  06A2 08               INC R0
  06A3 740E             MOV A, #0Eh
  06A5 F2               MOVX @R0, A
  06A6 08               INC R0
  06A7 7410             MOV A, #10h
  06A9 F2               MOVX @R0, A             ;           to_transmit = &i1_hid_descriptor;
  06AA 800B             SJMP L0367

L0366:                                          ;       } else {
  06AC 74FF             MOV A, #0FFh
  06AE F2               MOVX @R0, A             ;           transmit_addr_mode = CMEM_16;
  06AF 08               INC R0
  06B0 740D             MOV A, #0Dh
  06B2 F2               MOVX @R0, A
  06B3 08               INC R0
  06B4 74F7             MOV A, #0F7h
  06B6 F2               MOVX @R0, A             ;           to_transmit = &i0_hid_descriptor;
L0367:                                          ;       }
  06B7 7857             MOV R0, #57h
  06B9 E2               MOVX A, @R0
  06BA FB               MOV R3, A
  06BB 08               INC R0
  06BC E2               MOVX A, @R0
  06BD FA               MOV R2, A
  06BE 08               INC R0
  06BF E2               MOVX A, @R0
  06C0 F9               MOV R1, A
  06C1 120FBE           LCALL byte_read
L0381:
  06C4 7865             MOV R0, #65h
  06C6 F2               MOVX @R0, A             ;       X65 = *to_transmit; // byte_read(transmit_addr_mode, to_transmit);
  06C7 8038             SJMP L0369              ;       break;

L0375:                                          ;   case 0x22: // Report Descriptor
  06C9 781B             MOV R0, #1Bh
  06CB E2               MOVX A, @R0
  06CC 7857             MOV R0, #57h
  06CE 6010             JZ L0376                ;       if (LOBYTE(report.wIndex) != 0) {
  06D0 74FF             MOV A, #0FFh
  06D2 F2               MOVX @R0, A             ;           transmit_addr_mode = CMEM_16;
  06D3 08               INC R0
  06D4 740D             MOV A, #0Dh
  06D6 F2               MOVX @R0, A
  06D7 08               INC R0
  06D8 748D             MOV A, #8Dh
  06DA F2               MOVX @R0, A             ;           to_transmit = &i1_report_descriptor;
  06DB 900E17           MOV DPTR, #0E17h        ;           DPTR = &i1_hid_descriptor.wDescriptorLength;
  06DE 800E             SJMP L0377

L0376:                                          ;       } else {
  06E0 74FF             MOV A, #0FFh
  06E2 F2               MOVX @R0, A             ;           transmit_addr_mode = CMEM_16;
  06E3 08               INC R0
  06E4 740D             MOV A, #0Dh
  06E6 F2               MOVX @R0, A
  06E7 08               INC R0
  06E8 7444             MOV A, #44h
  06EA F2               MOVX @R0, A             ;           to_transmit = &i0_report_descriptor;
  06EB 900DFE           MOV DPTR, #0DFEh        ;           DPTR = &i0_hid_descriptor.wDescriptorLength;
L0377:                                          ;       }
  06EE E4               CLR A
  06EF 93               MOVC A, @A+DPTR
  06F0 7865             MOV R0, #65h
  06F2 F2               MOVX @R0, A
  06F3 A3               INC DPTR
  06F4 E4               CLR A
  06F5 93               MOVC A, @A+DPTR
  06F6 18               DEC R0
  06F7 F2               MOVX @R0, A             ;       Xw64 = *(__little_endian word*)DPTR;
  06F8 8007             SJMP L0369              ;       break;

L0379:                                          ;   default:
  06FA 90FFE1           MOV DPTR, #0FFE1h
  06FD E0               MOVX A, @DPTR
  06FE 44C0             ORL A, #0C0h
  0700 F0               MOVX @DPTR, A           ;       EPCON.RXSTL = EPCON.TXSTL = 1;
L0369:                                          ;   }
  0701 7864             MOV R0, #64h
  0703 E2               MOVX A, @R0
  0704 FE               MOV R6, A
  0705 08               INC R0
  0706 E2               MOVX A, @R0
  0707 FF               MOV R7, A
  0708 785F             MOV R0, #5Fh
  070A E2               MOVX A, @R0
  070B FC               MOV R4, A
  070C 08               INC R0
  070D E2               MOVX A, @R0
  070E FD               MOV R5, A
  070F D3               SETB C
  0710 9F               SUBB A, R7
  0711 EC               MOV A, R4
  0712 9E               SUBB A, R6
  0713 400E             JC L0370                ;   if (requested_size < Xw64 + 1) {
  0715 7864             MOV R0, #64h
  0717 E2               MOVX A, @R0
  0718 FF               MOV R7, A
  0719 08               INC R0
  071A E2               MOVX A, @R0
  071B 785C             MOV R0, #5Ch
  071D CF               XCH A, R7
  071E F2               MOVX @R0, A
  071F 08               INC R0
  0720 EF               MOV A, R7
  0721 F2               MOVX @R0, A             ;       tx_rx_count = Xw64;
  0722 22               RET

L0370:                                          ;   } else {
  0723 785C             MOV R0, #5Ch
  0725 EC               MOV A, R4
  0726 F2               MOVX @R0, A
  0727 08               INC R0
  0728 ED               MOV A, R5
  0729 F2               MOVX @R0, A             ;       tx_rx_count = requested_size;
  072A 22               RET                     ;}  }                       // tx_rx_count = max(requested_size, Xw64); // wtf

fn_keycodes:                                    ;static const byte fn_keycodes[18*8] = {
  072B 00008B0000000000                         ;   0,    0,      Muhen,  0,       0,    0,         0,      0,
  0733 0000000000000000                         ;   0,    0,      0,      0,       0,    0,         0,      0,
  073B 0000004700000000                         ;   0,    0,      0,      Scroll,  0,    0,         0,      0,
  0743 0000490000000000                         ;   0,    0,      Ins,    0,       0,    0,         0,      0,
  074B 0000000000000000                         ;   0,    0,      0,      0,       0,    0,         0,      0,
  0753 0000004600000000                         ;   0,    0,      0,      PrtScr,  0,    0,         0,      0,
  075B 0000000000000000                         ;   0,    0,      0,      0,       0,    0,         0,      0,
  0763 0000000000000000                         ;   0,    0,      0,      0,       0,    0,         0,      0,
  076B 0000000000000000                         ;   0,    0,      0,      0,       0,    0,         0,      0,
  0773 00E800E900930000                         ;   0,    Media0, 0,      Media1,  0,    Hiragana,  0,      0,
  077B 00EAF4EB00000000                         ;   0,    Media2, Media12,Media3,  0,    0,         0,      0,
  0783 0000000000000000                         ;   0,    0,      0,      0,       0,    0,         0,      0,
  078B 004800AD00000000                         ;   0,    Pause,  0,      WinBrk,  0,    0,         0,      0,
  0793 00AE000000000000                         ;   0,    CtrlBrk,0,      0,       0,    0,         0,      0,
  079B 00EC00ED00000000                         ;   0,    Media4, 0,      Media5,  0,    0,         0,      0,
  07A3 00EE00EF00000000                         ;   0,    Media6, 0,      Media7,  0,    0,         0,      0,
  07AB 00F000F100000000                         ;   0,    Media8, 0,      Media9,  0,    0,         0,      0,
  07B3 00F200F300000000                         ;   0,    Media10,0,      Media11, 0,    0,         0,      0
                                                ;}
num_keycodes:                                   ;static const byte num_keycodes[18*8] = {
  07BB 0000000000000000                         ;   0,   0, 0,       0,   0,   0,   0,   0,
  07C3 0000000000000000                         ;   0,   0, 0,       0,   0,   0,   0,   0,
  07CB 0000000000000000                         ;   0,   0, 0,       0,   0,   0,   0,   0,
  07D3 0000005700000000                         ;   0,   0, 0,       KP+, 0,   0,   0,   0,
  07DB 0000000000000000                         ;   0,   0, 0,       0,   0,   0,   0,   0,
  07E3 0000000000000000                         ;   0,   0, 0,       0,   0,   0,   0,   0,
  07EB 0000000000000000                         ;   0,   0, 0,       0,   0,   0,   0,   0,
  07F3 0000000000000000                         ;   0,   0, 0,       0,   0,   0,   0,   0,
  07FB 0000000000000000                         ;   0,   0, 0,       0,   0,   0,   0,   0,
  0803 0000000000000000                         ;   0,   0, 0,       0,   0,   0,   0,   0,
  080B 0000000000000000                         ;   0,   0, 0,       0,   0,   0,   0,   0,
  0813 000000605D5A0000                         ;   0,   0, KP/,     KP8, KP5, KP2, 0,   0,
  081B 0000000000000000                         ;   0,   0, 0,       0,   0,   0,   0,   0,
  0823 59005C5F00006200                         ;   KP1, 0, KP4,     KP7, 0,   0,   KP0, 0,
  082B 0000580000000000                         ;   0,   0, KPEnter, 0,   0,   0,   0,   0,
  0833 57000000615E635B                         ;   KP+, 0, 0,       0,   KP9, KP6, KP., KP3,
  083B 5400000000555600                         ;   KP/, 0, 0,       0,   0,   KP*, KP-, 0,
  0843 0000000000000000                         ;   0,   0, 0,       0,   0,   0,   0,   0
                                                ;}
decode_numlock:                                 ;void decode_numlock() {
  084B E4               CLR A
  084C 7853             MOV R0, #53h
  084E F6               MOV @R0, A
  084F 7856             MOV R0, #56h
  0851 7601             MOV @R0, #1h
L0160:                                          ;   for (byte __volatile(v53) i = 0, __volatile(v56) mask = 1;
                                                ;       i < 8; ++i, mask <<= 1) {
  0853 7853             MOV R0, #53h
  0855 E6               MOV A, @R0
  0856 C3               CLR C
  0857 9408             SUBB A, #8h
  0859 4003             JC L0156
  085B 020899           LJMP L0157

L0156:
  085E 7924             MOV R1, #24h
  0860 E7               MOV A, @R1
  0861 7856             MOV R0, #56h
  0863 56               ANL A, @R0
  0864 7003             JNZ L0158               ;       if (column_value & mask) {
  0866 02088E           LJMP L0159

L0158:
  0869 7823             MOV R0, #23h
  086B E6               MOV A, @R0
  086C 33               RLC A
  086D 33               RLC A
  086E 33               RLC A
  086F 54F8             ANL A, #0F8h
  0871 7853             MOV R0, #53h
  0873 26               ADD A, @R0
  0874 783B             MOV R0, #3Bh
  0876 F6               MOV @R0, A              ;           byte __volatile(v3B) key_index = column_index << 3 + i;
  0877 FF               MOV R7, A
  0878 120944           LCALL get_held_keycode  ;           R7 = get_held_keycode(key_index);
  087B 783C             MOV R0, #3Ch
  087D EF               MOV A, R7
  087E F6               MOV @R0, A              ;           keycode = R7
  087F C3               CLR C                   ;           // keycode is still in R7 and A
  0880 9459             SUBB A, #59h
  0882 4007             JC L0166
  0884 940B             SUBB A, #0Bh
  0886 5003             JNC L0166               ;           if (0x59 <= keycode <= 0x63) { // NumLock-dependent
  0888 121B01           LCALL trigger_numlock   ;               trigger_numlock();
L0166:                                          ;           } // if NumLock and kb_mode == 0x5A
  088B 1213E9           LCALL store_key         ;           store_key();
L0159:                                          ;       } // if
  088E 7853             MOV R0, #53h
  0890 06               INC @R0
  0891 7856             MOV R0, #56h
  0893 E6               MOV A, @R0
  0894 25E0             ADD A, ACC
  0896 F6               MOV @R0, A
  0897 80BA             SJMP L0160              ;   } // for
L0157:
  0899 22               RET                     ;}

;;; 17 bytes code
;;; By varying the loop limits at 089B and 08A7, we can change how often the keyboard is polled.
scan_delay:                                     ;void scan_delay() {
  089A 7E00             MOV R6, #0h
  089C EE               MOV A, R6
  089D 6007             JZ scan_delay__skip     ;   for (byte __register(R6) i = 0; i != 0; --i) {
scan_delay__loop:
  089F 7FFA             MOV R7, #0FAh
  08A1 121AA5           LCALL micro_delay       ;       micro_delay(250);
  08A4 DEF9             DJNZ R6, scan_delay__loop
scan_delay__skip:                               ;   }
  08A6 7F45             MOV R7, #45h
  08A8 021AA5           LJMP micro_delay        ;   micro_delay(69);
                                                ;}
;;; 3 bytes free

;;; 144 bytes free

CSEG AT 093Eh
;;; 6 bytes code, 24 bytes relocation unit
get_changed_keycode:                            ;byte __register(R7) get_changed_keycode(byte __register(R7) keyindex) { // R1 A
  093E E524             MOV A, 24h
  0940 5556             ANL A, 56h              ;   if (column_value & mask) {
  0942 700F             JNZ get_held_keycode__notfound
                                                ;       return get_pressed_keycode(keyindex);
                                                ;   } else {
                                                ;       return get_held_keycode(keyindex)
                                                ;   }
                                                ;}

;;; 18 bytes code
get_held_keycode:                               ;byte __register(R7) get_held_keycode(byte __register(R7) keyindex) { // R1 A
  0944 79E0             MOV R1, #0E0h           ;   for (PressedKey* __register(R1) p = &pressed_keys[0]; p != &pressed_keys[15]; ++p) {
get_held_keycode__loop:
  0946 E7               MOV A, @R1
  0947 09               INC R1
  0948 6F               XRL A, R7
  0949 7004             JNZ get_held_keycode__next ;    if (p->keyindex == keyindex) {
  094B E7               MOV A, @R1
  094C 02021F           LJMP do_get_keycode     ;           return do_get_keycode(keyindex, p->layer);
get_held_keycode__next:                         ;       }
  094F 09               INC R1
  0950 B9FEF3           CJNE R1, #0FEh, get_held_keycode__loop
                                                ;   }
get_held_keycode__notfound:
  0953 020B2F           LJMP get_pressed_keycode;   return get_pressed_keycode(keyindex); // not found
                                                ;}

;;; 10 bytes free

CSEG AT 0960h
do_usb_2:                                       ;void do_usb_2() {
  0960 90FFC9           MOV DPTR, #0FFC9h
  0963 E0               MOVX A, @DPTR
  0964 7863             MOV R0, #63h
  0966 F2               MOVX @R0, A             ;   X63 = UPCON;
  0967 E2               MOVX A, @R0
  0968 FF               MOV R7, A
  0969 540F             ANL A, #0Fh
  096B 7003             JNZ L0240               ;   if (X63 & 0x0F != 0) // URST (USB Reset) | URSM (USB Resume) | USUS (USB Suspend) | 0x08
  096D 0209FB           LJMP L0241              ;   {
L0240:
  0970 EF               MOV A, R7
  0971 30E05E           JNB ACC.0, L0324        ;       if (X63.USUS) {
  0974 E2               MOVX A, @R0
  0975 54F0             ANL A, #0F0h
  0977 F2               MOVX @R0, A             ;           X63 &= 0xF0; // CONEN | URWU | 0x50
  0978 4401             ORL A, #1h
  097A F0               MOVX @DPTR, A           ;           UPCON = X63 | USUS; // 0x01 USB Suspend Flag
  097B E0               MOVX A, @DPTR
  097C F2               MOVX @R0, A             ;           X63 = UPCON;
  097D E2               MOVX A, @R0
  097E 540F             ANL A, #0Fh
  0980 6003             JZ L0325                ;           if (X63 & 0x0F != 0)
  0982 020A6E           LJMP L0245              ;               return;

L0325:
  0985 121B3D           LCALL leds_off          ;           leds_off();
  0988 7814             MOV R0, #14h
  098A E2               MOVX A, @R0
  098B B40110           CJNE A, #1h, L0327      ;           if (remote_wakeup == 1) {
  098E E4               CLR A
  098F F590             MOV P1, A               ;               P1 = 0;
  0991 F5A0             MOV P2, A               ;               P2 = 0;
  0993 53B0E7           ANL P3, #0E7h           ;               P3 &= 0xE7; // xxx00xxx
  0996 75D5FF           MOV 0D5h, #0FFh         ;               KBPATN = 0xFF;
  0999 F5D6             MOV 0D6h, A             ;               KBCON = 0;
  099B 75D7FF           MOV 0D7h, #0FFh         ;               KBMASK = 0xFF;
L0327:                                          ;           }
  099E 438702           ORL PCON, #2h           ;           PCON |= PD; // Power-Down
  09A1 7F01             MOV R7, #1h
  09A3 121ADC           LCALL delay             ;           delay(1);
  09A6 7814             MOV R0, #14h
  09A8 E2               MOVX A, @R0
  09A9 B40119           CJNE A, #1h, L0328      ;           if (remote_wakeup == 1) {
  09AC E5D7             MOV A, 0D7h
  09AE 7009             JNZ L0329               ;               if (KBMASK == 0) {
  09B0 90FFC9           MOV DPTR, #0FFC9h
  09B3 E0               MOVX A, @DPTR
  09B4 4420             ORL A, #20h
  09B6 F0               MOVX @DPTR, A           ;                   UPCON |= URWU; // USB Remote Wake-Up Trigger
  09B7 8003             SJMP L0330
L0329:                                          ;               } else {
  09B9 E4               CLR A
  09BA F5D7             MOV 0D7h, A             ;                   KBMASK = 0;
L0330:                                          ;               }
  09BC 7590FF           MOV P1, #0FFh           ;               P1 = 0xFF;
  09BF 75A0FF           MOV P2, #0FFh           ;               P2 = 0xFF;
  09C2 43B018           ORL P3, #18h            ;               P3 |= 0x18; // xxx11xxx
L0328:                                          ;           }
  09C5 7815             MOV R0, #15h
  09C7 E2               MOVX A, @R0
  09C8 6401             XRL A, #1h
  09CA 6003             JZ L0331                ;           if (configured != true)
  09CC 020A6E           LJMP L0245              ;               return;
L0331:
  09CF 021AB0           LJMP upd_leds           ;           upd_leds(); return;
L0324:                                          ;       }
  09D2 7863             MOV R0, #63h
  09D4 E2               MOVX A, @R0
  09D5 FF               MOV R7, A               ;       R7 = X63;
  09D6 30E20F           JNB ACC.2, L0332        ;       if (X63.URST) {
  09D9 54F0             ANL A, #0F0h
  09DB F2               MOVX @R0, A             ;           X63 &= 0xF0; // CONEN | URWU | 0x50
  09DC 4404             ORL A, #4h
  09DE 90FFC9           MOV DPTR, #0FFC9h
  09E1 F0               MOVX @DPTR, A           ;           UPCON = X63 | URST;
  09E2 12177E           LCALL init_vars         ;           init_vars();
  09E5 021805           LJMP init_hw            ;           init_hw(); return;

L0332:                                          ;       }
  09E8 7863             MOV R0, #63h
  09EA E2               MOVX A, @R0
  09EB 20E103           JB ACC.1, L0333         ;       if (X63.URSM) {
  09EE 020A6E           LJMP L0245
L0333:
  09F1 54F0             ANL A, #0F0h
  09F3 F2               MOVX @R0, A             ;           X63 &= 0xF0; // CONEN | URWU | 0x50
  09F4 4402             ORL A, #2h
  09F6 90FFC9           MOV DPTR, #0FFC9h
  09F9 F0               MOVX @DPTR, A           ;           UPCON = X63 | URSM;
                                                ;       }
  09FA 22               RET                     ;       return;
L0241:                                          ;   }
  09FB 90FFDB           MOV DPTR, #0FFDBh
  09FE E0               MOVX A, @DPTR
  09FF 7863             MOV R0, #63h
  0A01 F2               MOVX @R0, A
  0A02 E2               MOVX A, @R0
  0A03 FD               MOV R5, A               ;   R5 = X63 = A = UIFLG;
  0A04 30E212           JNB ACC.2, L0242        ;   if (X63.UTXD1) {
  0A07 7404             MOV A, #4h
  0A09 F0               MOVX @DPTR, A           ;       UIFLG = UTXD1;
  0A0A 7401             MOV A, #1h
  0A0C 121B22           LCALL usb_transmit      ;       usb_transmit(1);
  0A0F 7838             MOV R0, #38h
  0A11 E6               MOV A, @R0
  0A12 6401             XRL A, #1h
  0A14 7046             JNZ L0244               ;       if (usb1_transmitting == 1)
  0A16 F6               MOV @R0, A              ;           usb1_transmitting = 0;
  0A17 8043             SJMP L0244              ;
L0242:                                          ;   } else
  0A19 ED               MOV A, R5
  0A1A 30E415           JNB ACC.4, L0246        ;   if (X63.UTXD2) {
  0A1D 90FFDB           MOV DPTR, #0FFDBh
  0A20 7410             MOV A, #10h
  0A22 F0               MOVX @DPTR, A           ;       UIFLG = UTXD2;
  0A23 7402             MOV A, #2h
  0A25 121B22           LCALL usb_transmit      ;       usb_transmit(2);
  0A28 7845             MOV R0, #45h
  0A2A E6               MOV A, @R0
  0A2B 6401             XRL A, #1h
  0A2D 702D             JNZ L0244               ;       if (usb2_transmitting == 1)
  0A2F F6               MOV @R0, A              ;           usb2_transmitting = 0;
  0A30 802A             SJMP L0244
L0246:                                          ;   } else
  0A32 7863             MOV R0, #63h
  0A34 E2               MOVX A, @R0
  0A35 30E110           JNB ACC.1, L0247        ;   if (X63.URXD0) {
  0A38 90FFDB           MOV DPTR, #0FFDBh
  0A3B 7402             MOV A, #2h
  0A3D F0               MOVX @DPTR, A           ;       UIFLG = URXD0;
  0A3E 90FFF1           MOV DPTR, #0FFF1h
  0A41 E4               CLR A
  0A42 F0               MOVX @DPTR, A           ;       EPINDEX = 0;
  0A43 1218B5           LCALL received_ep0      ;       received_ep0();
  0A46 8014             SJMP L0244

L0247:                                          ;   } else
  0A48 7863             MOV R0, #63h
  0A4A E2               MOVX A, @R0
  0A4B 30E00E           JNB ACC.0, L0244        ;   if (X63.UTXD0) {
  0A4E 90FFDB           MOV DPTR, #0FFDBh
  0A51 7401             MOV A, #1h
  0A53 F0               MOVX @DPTR, A           ;       UIFLG = UTXD0;
  0A54 90FFF1           MOV DPTR, #0FFF1h
  0A57 E4               CLR A
  0A58 F0               MOVX @DPTR, A           ;       EPINDEX = 0;
  0A59 120EF4           LCALL do_transmit       ;       do_transmit();
L0244:                                          ;   }
  0A5C 7863             MOV R0, #63h
  0A5E E2               MOVX A, @R0
  0A5F 30E70C           JNB ACC.7, L0245        ;   if (X63.SOFIF) {
  0A62 90FFDB           MOV DPTR, #0FFDBh
  0A65 7480             MOV A, #80h
  0A67 F0               MOVX @DPTR, A           ;       UIFLG = SOFIF;
  0A68 7843             MOV R0, #43h
  0A6A E6               MOV A, @R0
  0A6B 6001             JZ L0245                ;       if (usb_intr_count)
  0A6D 16               DEC @R0                 ;           --usb_intr_count;
L0245:                                          ;   }
  0A6E 22               RET                     ;}

stop_fn:                                        ;void stop_fn() {
  0A6F 7846             MOV R0, #46h
  0A71 7601             MOV @R0, #1h            ;   media_report_ready = 1;
  0A73 E4               CLR A
  0A74 08               INC R0
  0A75 F6               MOV @R0, A              ;   media_keycode = 0;
                                                ;   hid_report2[0] = 1; hid_report2[1] = 0;
                                                ;}
process_fn:                                     ;void process_fn() {
  0A76 7847             MOV R0, #47h
  0A78 E6               MOV A, @R0
  0A79 C3               CLR C
  0A7A 94E8             SUBB A, #0E8h
  0A7C 4008             JC L9000                ;    if (media_keycode >= 0xE8) {
  0A7E 7848             MOV R0, #48h
  0A80 7601             MOV @R0, #1h            ;        hid_report2[0] = 1;
  0A82 08               INC R0
  0A83 04               INC A
  0A84 F6               MOV @R0, A              ;        hid_report2[1] = media_keycode - 0xE7;
  0A85 22               RET                     ;        return;
L9000:                                          ;    }
  0A86 7848             MOV R0, #48h
  0A88 7601             MOV @R0, #1h            ;    hid_report2[0] = 1;
  0A8A 08               INC R0
  0A8B E4               CLR A
  0A8C F6               MOV @R0, A              ;    hid_report2[1] = 0;
  0A8D 22               RET                     ;}

;;; 134 bytes free

CSEG AT 0B14h
;;; 27 bytes code
get_layer:                                      ;byte __register(A) get_layer() { // R0
  0B14 7803             MOV R0, #3h
  0B16 E2               MOVX A, @R0
  0B17 6002             JZ get_layer_fnup
  0B19 7404             MOV A, #4h
get_layer_fnup:
  0B1B 6407             XRL A, #7h              ;   bool fnup = !fn_down;

  0B1D A2EA             MOV C, 0EAh
  0B1F 33               RLC A                   ;   return ~((((((3 << 1 | P4./DIP1)
  0B20 A2E9             MOV C, 0E9h
  0B22 33               RLC A                   ;                   << 1 | P4./DIP2)
  0B23 A2B2             MOV C, P3.2
  0B25 33               RLC A                   ;                   << 1 | P3./DIP3)
  0B26 A2B1             MOV C, P3.1
  0B28 33               RLC A                   ;                   << 1 | P3./DIP4)
  0B29 A2B5             MOV C, P3.5
  0B2B 33               RLC A                   ;                   << 1 | P3./NUM)
  0B2C 23               RL A                    ;                   << 1 | fnup);
  0B2D F4               CPL A
  0B2E 22               RET
                                                ;}

;;; 6 bytes code
get_pressed_keycode:                            ;byte __register(R7) get_pressed_keycode(byte __register(R7) keyindex) { // R0 R1 A DPTR R7
  0B2F 120B14           LCALL get_layer
  0B32 02021F           LJMP do_get_keycode     ;   return do_get_keycode(keyindex, get_layer());
                                                ;}

;;; 19 bytes code
;;; Mark key as pressed in the current layer.
store_pressed_key:                              ;void store_pressed_key(byte __register(R0) keyindex) { // R0 R1 A
  0B35 79E0             MOV R1, #0E0h           ;   for (PressedKey* __register(R1) p = &pressed_keys[0]; p != &pressed_keys[15]; ++p) {
store_pressed_key__loop:
  0B37 E7               MOV A, @R1
  0B38 7008             JNZ store_pressed_key__next;    if (p->keyindex == 0) {
  0B3A E8               MOV A, R0
  0B3B F7               MOV @R1, A              ;           p->keyindex = keyindex;
  0B3C 09               INC R1
  0B3D 120B14           LCALL get_layer
  0B40 F7               MOV @R1, A              ;           p->layer = get_layer();
  0B41 22               RET                     ;           return;
store_pressed_key__next:                        ;       }
  0B42 09               INC R1
  0B43 09               INC R1
  0B44 B9FEF0           CJNE R1, #0FEh, store_pressed_key__loop
                                                ;   }
  0B47 22               RET                     ;}

;;; 14 bytes code
;;; Mark key as released.
clear_pressed_key:                              ;void clear_pressed_key(byte __register(R0) keyindex) { // R1 A
  0B48 79E0             MOV R1, #0E0h           ;   for (PressedKey* __register(R1) p = &pressed_keys[0]; p != &pressed_keys[15]; ++p) {
clear_pressed_key__loop:
  0B4A E8               MOV A, R0
  0B4B 67               XRL A, @R1
  0B4C 7002             JNZ clear_pressed_key__next
                                                ;       if (p->keyindex == keyindex) {
  0B4E F7               MOV @R1, A              ;           p->keyindex = 0;
  0B4F 22               RET                     ;           return;
clear_pressed_key__next:                        ;       }
  0B50 09               INC R1
  0B51 09               INC R1
  0B52 B9FEF5           CJNE R1, #0FEh, clear_pressed_key__loop
                                                ;   }
  0B55 22               RET                     ;}

;;; 16 bytes code
;;; in: byte __volatile(v23) column_index, __volatile(v24) column_value, __volatile(v53) i, __volatile(v56) mask;
;;; inout: struct PressedKey { byte keyindex; byte layer; } __volatile(vE0) pressed_keys[15];
;;; uses registers: A R0 R1
update_pressed_keys:                            ;void update_pressed_keys() {
  0B56 E523             MOV A, 23h
  0B58 23               RL A
  0B59 23               RL A
  0B5A 23               RL A
  0B5B 4553             ORL A, 53h
  0B5D F8               MOV R0, A               ;   byte __register(R0) keyindex = column_index << 3 | i;
  0B5E E524             MOV A, 24h
  0B60 5556             ANL A, 56h              ;   if (column_value & mask) {
  0B62 70D1             JNZ store_pressed_key   ;       store_pressed_key(keyindex);
                                                ;   } else {
  0B64 80E2             SJMP clear_pressed_key  ;       clear_pressed_key(keyindex);
                                                ;   }
                                                ;}

;;; 3 bytes free

CSEG AT 0B69h
find_macro:                                     ;bool __register(C) find_macro(byte* __register(R0) p) {
  0B69 E6               MOV A, @R0
  0B6A 244D             ADD A, #4Dh
  0B6C F8               MOV R0, A
  0B6D E6               MOV A, @R0
  0B6E 783C             MOV R0, #3Ch
  0B70 F6               MOV @R0, A              ;   keycode = keys_down[*p];
  0B71 E4               CLR A
  0B72 7859             MOV R0, #59h
  0B74 F6               MOV @R0, A
  0B75 08               INC R0
  0B76 F6               MOV @R0, A              ;   macro = NULL;
  0B77 783C             MOV R0, #3Ch
  0B79 E6               MOV A, @R0
  0B7A 7003             JNZ L0084
  0B7C 020C5F           LJMP L0085              ;   if (keycode == 0) return false;

L0084:
  0B7F 13               RRC A
  0B80 13               RRC A
  0B81 13               RRC A
  0B82 541F             ANL A, #1Fh
  0B84 902800           MOV DPTR, #02800h
  0B87 93               MOVC A, @A+DPTR
  0B88 7856             MOV R0, #56h
  0B8A F6               MOV @R0, A              ;   v56 = macros.disabled[keycode >> 3];
  0B8B 783C             MOV R0, #3Ch
  0B8D E6               MOV A, @R0
  0B8E 5407             ANL A, #7h
  0B90 7953             MOV R1, #53h
  0B92 F7               MOV @R1, A              ;   v53 = keycode & 7;
  0B93 7853             MOV R0, #53h
  0B95 E6               MOV A, @R0
  0B96 FF               MOV R7, A
  0B97 7856             MOV R0, #56h
  0B99 E6               MOV A, @R0
  0B9A FE               MOV R6, A
  0B9B C8               XCH A, R0
  0B9C EF               MOV A, R7
  0B9D C8               XCH A, R0
  0B9E 08               INC R0
  0B9F 8002             SJMP L0086

L0087:
  0BA1 C3               CLR C
  0BA2 13               RRC A
L0086:
  0BA3 D8FC             DJNZ R0, L0087
  0BA5 30E003           JNB ACC.0, L0088
  0BA8 020C5F           LJMP L0085              ;   if ((v56 >> v53) & 0x01) return false;

L0088:
  0BAB 902820           MOV DPTR, #02820h
  0BAE E4               CLR A
  0BAF 93               MOVC A, @A+DPTR
  0BB0 7856             MOV R0, #56h
  0BB2 F6               MOV @R0, A              ;   byte __volatile(v56) n = macros.binding_count;
  0BB3 08               INC R0
  0BB4 7628             MOV @R0, #28h
  0BB6 08               INC R0
  0BB7 7621             MOV @R0, #21h
  0BB9 E4               CLR A
  0BBA 7854             MOV R0, #54h
  0BBC F6               MOV @R0, A
L0094:                                          ;   for (byte __volatile(v54) i = 0, word __volatile(vw57) pBinding = &macros.bindings[0]; i < n; ++pBinding, ++i) {
  0BBD 7954             MOV R1, #54h
  0BBF E7               MOV A, @R1
  0BC0 C3               CLR C
  0BC1 7856             MOV R0, #56h
  0BC3 96               SUBB A, @R0
  0BC4 4003             JC L0089
  0BC6 020C5F           LJMP L0085

L0089:
  0BC9 08               INC R0
  0BCA E6               MOV A, @R0
  0BCB FE               MOV R6, A
  0BCC 08               INC R0
  0BCD E6               MOV A, @R0
  0BCE F582             MOV DPL, A
  0BD0 8E83             MOV DPH, R6
  0BD2 E4               CLR A
  0BD3 93               MOVC A, @A+DPTR
  0BD4 783C             MOV R0, #3Ch
  0BD6 66               XRL A, @R0
  0BD7 7076             JNZ L0090               ;       if (pBinding->keycode != keycode) continue;
  0BD9 784B             MOV R0, #4Bh
  0BDB E6               MOV A, @R0
  0BDC 5407             ANL A, #7h
  0BDE FF               MOV R7, A
  0BDF 783F             MOV R0, #3Fh
  0BE1 F6               MOV @R0, A              ;       byte __volatile(v3F) modifiers = R7 = key_modifiers & (LAlt | LShift | LCtrl);
  0BE2 784B             MOV R0, #4Bh
  0BE4 E6               MOV A, @R0
  0BE5 C4               SWAP A
  0BE6 5407             ANL A, #7h
  0BE8 4F               ORL A, R7
  0BE9 783F             MOV R0, #3Fh
  0BEB F6               MOV @R0, A              ;       modifiers = R7 | (key_modifiers >> 4) & (LAlt | LShift | LCtrl);
  0BEC E4               CLR A
  0BED 7853             MOV R0, #53h
  0BEF F6               MOV @R0, A
L0093:                                          ;       for (byte __volatile(v53) j = 0; j != 8; ++pBinding, ++j) {
  0BF0 7857             MOV R0, #57h
  0BF2 E6               MOV A, @R0
  0BF3 FE               MOV R6, A
  0BF4 08               INC R0
  0BF5 E6               MOV A, @R0
  0BF6 F582             MOV DPL, A
  0BF8 8E83             MOV DPH, R6
  0BFA E4               CLR A
  0BFB 93               MOVC A, @A+DPTR
  0BFC 783C             MOV R0, #3Ch
  0BFE 66               XRL A, @R0
  0BFF 7038             JNZ L0091               ;           if (pBinding->keycode != keycode) return false;
  0C01 04               INC A
  0C02 93               MOVC A, @A+DPTR
  0C03 783F             MOV R0, #3Fh
  0C05 66               XRL A, @R0
  0C06 7033             JNZ L0092               ;           if (pBinding->modifiers != modifiers) continue;
  0C08 7857             MOV R0, #57h
  0C0A E6               MOV A, @R0
  0C0B FE               MOV R6, A
  0C0C 08               INC R0
  0C0D E6               MOV A, @R0
  0C0E F582             MOV DPL, A
  0C10 8E83             MOV DPH, R6
  0C12 7402             MOV A, #2h
  0C14 93               MOVC A, @A+DPTR
  0C15 08               INC R0
  0C16 F6               MOV @R0, A
  0C17 7857             MOV R0, #57h
  0C19 E6               MOV A, @R0
  0C1A FE               MOV R6, A
  0C1B 08               INC R0
  0C1C E6               MOV A, @R0
  0C1D F582             MOV DPL, A
  0C1F 8E83             MOV DPH, R6
  0C21 7403             MOV A, #3h
  0C23 93               MOVC A, @A+DPTR
  0C24 785A             MOV R0, #5Ah
  0C26 F6               MOV @R0, A              ;           pMacro = pBinding->pItems;
  0C27 7857             MOV R0, #57h
  0C29 E6               MOV A, @R0
  0C2A FE               MOV R6, A
  0C2B 08               INC R0
  0C2C E6               MOV A, @R0
  0C2D F582             MOV DPL, A
  0C2F 8E83             MOV DPH, R6
  0C31 7404             MOV A, #4h
  0C33 93               MOVC A, @A+DPTR
  0C34 7840             MOV R0, #40h
  0C36 F6               MOV @R0, A              ;           macro_delay_after = pBinding->delay_after;
  0C37 D3               SETB C
  0C38 22               RET                     ;           return true;

L0091:
  0C39 C3               CLR C
  0C3A 22               RET

L0092:
  0C3B 7858             MOV R0, #58h
  0C3D 7405             MOV A, #5h
  0C3F 26               ADD A, @R0
  0C40 F6               MOV @R0, A
  0C41 18               DEC R0
  0C42 E4               CLR A
  0C43 36               ADDC A, @R0
  0C44 F6               MOV @R0, A
  0C45 7853             MOV R0, #53h
  0C47 06               INC @R0
  0C48 E6               MOV A, @R0
  0C49 6408             XRL A, #8h
  0C4B 70A3             JNZ L0093               ;       } // for j
  0C4D C3               CLR C
  0C4E 22               RET                     ;       return false; // found keycode, did not find modifiers

L0090:
  0C4F 7858             MOV R0, #58h
  0C51 7405             MOV A, #5h
  0C53 26               ADD A, @R0
  0C54 F6               MOV @R0, A
  0C55 18               DEC R0
  0C56 E4               CLR A
  0C57 36               ADDC A, @R0
  0C58 F6               MOV @R0, A
  0C59 7854             MOV R0, #54h
  0C5B 06               INC @R0
  0C5C 020BBD           LJMP L0094

L0085:                                          ;   } // for i
  0C5F C3               CLR C
  0C60 22               RET                     ;   return false; // did not find keycode
                                                ;}

decode_fn:                                      ;void decode_fn() {
  0C61 E4               CLR A
  0C62 7853             MOV R0, #53h
  0C64 F6               MOV @R0, A
  0C65 7856             MOV R0, #56h
  0C67 7601             MOV @R0, #1h
  0C69 7825             MOV R0, #25h
  0C6B E6               MOV A, @R0
  0C6C 7924             MOV R1, #24h
  0C6E 67               XRL A, @R1
  0C6F F6               MOV @R0, A              ;   column_changed = old_column_value ^ column_value;
L0196:                                          ;   for (byte __volatile(v53) i = 0, __volatile(v56) mask = 1; i < 8; ++i, mask <<= 1) {
  0C70 7853             MOV R0, #53h
  0C72 E6               MOV A, @R0
  0C73 C3               CLR C
  0C74 9408             SUBB A, #8h
  0C76 4003             JC L0192
  0C78 020D43           LJMP L0193
L0192:
  0C7B 7925             MOV R1, #25h
  0C7D E7               MOV A, @R1
  0C7E 7856             MOV R0, #56h
  0C80 56               ANL A, @R0
  0C81 7003             JNZ L0194
  0C83 020D37           LJMP L0195              ;       if (column_changed & mask) {
L0194:
  0C86 7823             MOV R0, #23h
  0C88 E6               MOV A, @R0
  0C89 33               RLC A
  0C8A 33               RLC A
  0C8B 33               RLC A
  0C8C 54F8             ANL A, #0F8h
  0C8E 7853             MOV R0, #53h
  0C90 26               ADD A, @R0
  0C91 783B             MOV R0, #3Bh
  0C93 F6               MOV @R0, A              ;           byte __volatile(v3B) key_index = column_index << 3 + i;
  0C94 FF               MOV R7, A
  0C95 12093E           LCALL get_changed_keycode ;         R7 = get_changed_keycode(key_index);
  0C98 120B56           LCALL update_pressed_keys ;         update_pressed_keys();
  0C9B 783C             MOV R0, #3Ch
  0C9D EF               MOV A, R7
  0C9E F6               MOV @R0, A              ;           keycode = R7;
  0C9F B4DF0D           CJNE A, #0DFh, L9700    ;           if (keycode == 0xDF) { // Fn
  0CA2 E524             MOV A, 24h
  0CA4 5556             ANL A, 56h
  0CA6 7803             MOV R0, #3h
  0CA8 6002             JZ L9701                ;               if (column_value & mask) { // pressed
  0CAA 7480             MOV A, #80h             ;                   fn_down = true;
                                                ;               } else {
                                                ;                   fn_down = false;
L9701:
  0CAC F2               MOVX @R0, A
                                                ;               }
  0CAD 800B             SJMP L0195              ;               continue;
                                                ;           }
L9700:
  0CAF B4DE15           CJNE A, #0DEh, L9702    ;           if (keycode == 0xDE) { // IntNum
  0CB2 E524             MOV A, 24h
  0CB4 5556             ANL A, 56h
  0CB6 6002             JZ L9703                ;               if (column_value & mask) {
  0CB8 B2B5             CPL P3.5                ;                   P3./NUM = not P3./NUM;
L9703:                                          ;               }
  0CBA 807B             SJMP L0195              ;               continue;
;;; 11 bytes free
CSEG AT 0CC7h
L9702:                                          ;           }
  0CC7 783C             MOV R0, #3Ch
  0CC9 E6               MOV A, @R0
  0CCA FE               MOV R6, A
  0CCB C3               CLR C
  0CCC 94E8             SUBB A, #0E8h
  0CCE 4063             JC L0209                ;           if (keycode >= 0xE8 // MediaFirst
  0CD0 EE               MOV A, R6
  0CD1 D3               SETB C
  0CD2 94FE             SUBB A, #0FEh
  0CD4 505D             JNC L0209               ;               and keycode <= 0xFE) // MediaLast
                                                ;           {
  0CD6 E524             MOV A, 24h
  0CD8 5556             ANL A, 56h
  0CDA 600C             JZ decode_fn__media_up  ;               if (column_value & mask) { // down
  0CDC 7846             MOV R0, #46h
  0CDE 7601             MOV @R0, #1h            ;                   media_report_ready = 1;
  0CE0 08               INC R0
  0CE1 A63C             MOV @R0, 3Ch            ;                   media_keycode = keycode;
  0CE3 120A76           LCALL process_fn        ;                   process_fn();
  0CE6 804F             SJMP L0195              ;                   continue;
decode_fn__media_up:                            ;               } else { // up
  0CE8 120A6F           LCALL stop_fn           ;                   stop_fn();
  0CEB 804A             SJMP L0195              ;                   continue;
                                                ;               }
                                                ;           }
;;; 70 bytes free

CSEG AT 0D33h
L0209:
  0D33 783E             MOV R0, #3Eh
  0D35 7601             MOV @R0, #1h            ;           normal_key = true;
L0195:                                          ;       }
  0D37 7853             MOV R0, #53h
  0D39 06               INC @R0
  0D3A 7856             MOV R0, #56h
  0D3C E6               MOV A, @R0
  0D3D 25E0             ADD A, ACC
  0D3F F6               MOV @R0, A
  0D40 020C70           LJMP L0196              ;   } // for i, mask
L0193:
  0D43 22               RET                     ;}

                                                ;struct ReportDescriptor i0_report_descriptor = {
  0D44 05               DB 005h
  0D45 01               DB 001h                 ;   Usage Page(1); // Generic Desktop
  0D46 09               DB 009h
  0D47 06               DB 006h                 ;   Usage(6);
  0D48 A1               DB 0A1h
  0D49 01               DB 001h                 ;   Collection(Application);
  0D4A 05               DB 005h
  0D4B 07               DB 007h                 ;       Usage Page(7); // Keyboard/Keypad

  0D4C 19               DB 019h
  0D4D E0               DB 0E0h                 ;       Usage Minimum(0xE0); // LCtrl
  0D4E 29               DB 029h
  0D4F E7               DB 0E7h                 ;       Usage Maximum(0xE7); // RGUI
  0D50 15               DB 015h
  0D51 00               DB 000h                 ;       Logical Minimum(0);
  0D52 25               DB 025h
  0D53 01               DB 001h                 ;       Logical Maximum(1);
  0D54 75               DB 075h
  0D55 01               DB 001h                 ;       Report Size(1);
  0D56 95               DB 095h
  0D57 08               DB 008h                 ;       Report Count(8);
  0D58 81               DB 081h
  0D59 02               DB 002h                 ;       Input(Data|Variable|Absolute|No Wrap|Linear|Preferred State|No Null|Non Volatile);

  0D5A 95               DB 095h
  0D5B 01               DB 001h                 ;       Report Count(1);
  0D5C 75               DB 075h
  0D5D 08               DB 008h                 ;       Report Size(8);
  0D5E 81               DB 081h
  0D5F 01               DB 001h                 ;       Input(Constant|Array|Absolute|No Wrap|Linear|Preferred State|No Null|Non Volatile);

  0D60 95               DB 095h
  0D61 03               DB 003h                 ;       Report Count(3);
  0D62 75               DB 075h
  0D63 01               DB 001h                 ;       Report Size(1);
  0D64 05               DB 005h
  0D65 08               DB 008h                 ;       Usage Page(8); // LED
  0D66 19               DB 019h
  0D67 01               DB 001h                 ;       Usage Minimum(1);
  0D68 29               DB 029h
  0D69 03               DB 003h                 ;       Usage Maximum(3);
  0D6A 91               DB 091h
  0D6B 02               DB 002h                 ;       Output(Data|Variable|Absolute|No Wrap|Linear|Preferred State|No Null|Non Volatile);

  0D6C 95               DB 095h
  0D6D 05               DB 005h                 ;       Report Count(5);
  0D6E 75               DB 075h
  0D6F 01               DB 001h                 ;       Report Size(1);
  0D70 91               DB 091h
  0D71 01               DB 001h                 ;       Output(Constant|Array|Absolute|No Wrap|Linear|Preferred State|No Null|Non Volatile);

  0D72 95               DB 095h
  0D73 06               DB 006h                 ;       Report Count(6);
  0D74 75               DB 075h
  0D75 08               DB 008h                 ;       Report Size(8);
  0D76 15               DB 015h
  0D77 00               DB 000h                 ;       Logical Minimum(0);
  0D78 26               DB 026h
  0D79 FF               DB 0FFh
  0D7A 00               DB 000h                 ;       Logical Maximum(0xFF);
  0D7B 05               DB 005h
  0D7C 07               DB 007h                 ;       Usage Page(7); // Keyboard/Keypad
  0D7D 19               DB 019h
  0D7E 00               DB 000h                 ;       Usage Minimum(0);
  0D7F 2A               DB 02Ah
  0D80 FF               DB 0FFh
  0D81 00               DB 000h                 ;       Usage Maximum(0xFF);
  0D82 81               DB 081h
  0D83 00               DB 000h                 ;       Input(Data|Array|Absolute|No Wrap|Linear|Preferred State|No Null|Non Volatile)

  0D84 09               DB 009h
  0D85 00               DB 000h                 ;       Usage(0);
  0D86 95               DB 095h
  0D87 40               DB 040h                 ;       Report Count(64);
  0D88 75               DB 075h
  0D89 08               DB 008h                 ;       Report Size(8);
  0D8A B1               DB 0B1h
  0D8B 00               DB 000h                 ;       Feature(Data|Array|Absolute|No Wrap|Linear|Preferred State|No Null|Non Volatile);
  0D8C C0               DB 0C0h                 ;   End Collection;
                                                ;};

                                                ;struct ReportDescriptor i1_report_descriptor = {
  0D8D 05               DB 005h
  0D8E 0C               DB 00Ch                 ;   Usage Page(0x0C); // Consumer
  0D8F 09               DB 009h
  0D90 01               DB 001h                 ;   Usage(1);
  0D91 A1               DB 0A1h
  0D92 01               DB 001h                 ;   Collection(Application);
  0D93 85               DB 085h
  0D94 01               DB 001h                 ;       Report ID(1);
  0D95 15               DB 015h
  0D96 01               DB 001h                 ;       Logical Minimum(1);
  0D97 25               DB 025h
  0D98 17               DB 017h                 ;       Logical Maximum(0x17);
  0D99 75               DB 075h
  0D9A 08               DB 008h                 ;       Report Size(8);
  0D9B 95               DB 095h
  0D9C 01               DB 001h                 ;       Report Count(1);
  0D9D 0A               DB 00Ah
  0D9E 23               DB 023h
  0D9F 02               DB 002h                 ;       Usage(0x0223);  // 1 => AC Home
  0DA0 0A               DB 00Ah
  0DA1 8A               DB 08Ah
  0DA2 01               DB 001h                 ;       Usage(0x018A);  // 2 => AC Email Reader
  0DA3 0A               DB 00Ah
  0DA4 21               DB 021h
  0DA5 02               DB 002h                 ;       Usage(0x0221);  // 3 => AL Search
  0DA6 0A               DB 00Ah
  0DA7 94               DB 094h
  0DA8 01               DB 001h                 ;       Usage(0x0194);  // 4 => AL Local Machine Browser
  0DA9 0A               DB 00Ah
  0DAA 92               DB 092h
  0DAB 01               DB 001h                 ;       Usage(0x0194);  // 5 => AL Calculator
  0DAC 0A               DB 00Ah
  0DAD 83               DB 083h
  0DAE 01               DB 001h                 ;       Usage(0x0183);  // 6 => AL Consumer Control Configuration
  0DAF 0A               DB 00Ah
  0DB0 B6               DB 0B6h
  0DB1 00               DB 000h                 ;       Usage(0x00B6);  // 7 => Scan Previous Track
  0DB2 0A               DB 00Ah
  0DB3 CD               DB 0CDh
  0DB4 00               DB 000h                 ;       Usage(0x00CD);  // 8 => Play/Pause
  0DB5 0A               DB 00Ah
  0DB6 B5               DB 0B5h
  0DB7 00               DB 000h                 ;       Usage(0x00B5);  // 9 => Scan Next Track
  0DB8 0A               DB 00Ah
  0DB9 E2               DB 0E2h
  0DBA 00               DB 000h                 ;       Usage(0x00E2);  // 0x0A => Mute
  0DBB 0A               DB 00Ah
  0DBC EA               DB 0EAh
  0DBD 00               DB 000h                 ;       Usage(0x00EA);  // 0x0B => Volume Decrement
  0DBE 0A               DB 00Ah
  0DBF E9               DB 0E9h
  0DC0 00               DB 000h                 ;       Usage(0x00E9);  // 0x0C => Volume Increment
  0DC1 0A               DB 00Ah
  0DC2 B8               DB 0B8h
  0DC3 00               DB 000h                 ;       Usage(0x00B8);  // 0x0D => Eject
  0DC4 0A               DB 00Ah
  0DC5 00               DB 000h
  0DC6 00               DB 000h                 ;       Usage(0x0000);  // 0x0E =>
  0DC7 0A               DB 00Ah
  0DC8 00               DB 000h
  0DC9 00               DB 000h                 ;       Usage(0x0000);  // 0x0F =>
  0DCA 0A               DB 00Ah
  0DCB 00               DB 000h
  0DCC 00               DB 000h                 ;       Usage(0x0000);  // 0x10 => 
  0DCD 0A               DB 00Ah
  0DCE 00               DB 000h
  0DCF 00               DB 000h                 ;       Usage(0x0000);  // 0x11 => 
  0DD0 0A               DB 00Ah
  0DD1 00               DB 000h
  0DD2 00               DB 000h                 ;       Usage(0x0000);  // 0x12 =>
  0DD3 0A               DB 00Ah
  0DD4 00               DB 000h
  0DD5 00               DB 000h                 ;       Usage(0x0000);  // 0x13 =>
  0DD6 0A               DB 00Ah
  0DD7 00               DB 000h
  0DD8 00               DB 000h                 ;       Usage(0x0000);  // 0x14 =>
  0DD9 0A               DB 00Ah
  0DDA 00               DB 000h
  0DDB 00               DB 000h                 ;       Usage(0x0000);  // 0x15 =>
  0DDC 0A               DB 00Ah
  0DDD 00               DB 000h
  0DDE 00               DB 000h                 ;       Usage(0x0000);  // 0x16 =>
  0DDF 0A               DB 00Ah
  0DE0 00               DB 000h
  0DE1 00               DB 000h                 ;       Usage(0x0191);  // 0x17 =>
  0DE2 81               DB 081h
  0DE3 60               DB 060h                 ;       Input(Data|Array|Absolute|No Wrap|Linear|No Preferred|Null State);
  0DE4 C0               DB 0C0h                 ;   End Collection;
                                                ;};

                                                ;struct ConfigurationDescriptor configuration_descriptor = {
  0DE5 09               DB 009h                 ;   byte bLength = 9;
  0DE6 02               DB 002h                 ;   byte bDescriptorType = CONFIGURATION;
  0DE7 3B               DB 03Bh
  0DE8 00               DB 000h                 ;   word wTotalLength = 0x3B; // 59
  0DE9 02               DB 002h                 ;   byte bNumInterfaces = 2;
  0DEA 01               DB 001h                 ;   byte bConfigurationValue = 1;
  0DEB 00               DB 000h                 ;   byte iConfiguration = 0; // No string
  0DEC A0               DB 0A0h                 ;   byte bmAttributes = 0xA0; // Self-powered, no remote wakeup
  0DED 32               DB 032h                 ;   byte bMaxPower = 50; // 100mA
                                                ;};
                                                ;struct InterfaceDescriptor interface_descriptor_0 = {
  0DEE 09               DB 009h                 ;   byte bLength = 9;
  0DEF 04               DB 004h                 ;   byte bDescriptorType = INTERFACE;
  0DF0 00               DB 000h                 ;   byte bInterfaceNumber = 0;
  0DF1 00               DB 000h                 ;   byte bAlternateSetting = 0;
  0DF2 01               DB 001h                 ;   byte bNumEndpoints = 1;
  0DF3 03               DB 003h                 ;   byte bInterfaceClass = HID_CLASS;
  0DF4 01               DB 001h                 ;   byte bInterfaceSubclass = HID_BOOT_SUBCLASS;
  0DF5 01               DB 001h                 ;   byte bInterfaceProtocol = HID_KEYBOARD_PROTOCOL;
  0DF6 00               DB 000h                 ;   byte iInterface = 0; // No string
                                                ;};
                                                ;struct HidDescriptor i0_hid_descriptor = {
  0DF7 09               DB 009h                 ;   byte bLength = 9;
  0DF8 21               DB 021h                 ;   byte bDescriptorType = HID;
  0DF9 11               DB 011h
  0DFA 01               DB 001h                 ;   word bcdHID = 0x111, 1.11;
  0DFB 00               DB 000h                 ;   byte bCountryCode = 0, Not supported
  0DFC 01               DB 001h                 ;   byte bNumDescriptors = 1;
  0DFD 22               DB 022h                 ;   byte bDescriptorType = 0x22; // REPORT
  0DFE 49               DB 049h
  0DFF 00               DB 000h                 ;   word wDescriptorLength = 0x49;
                                                ;};
                                                ;struct EndpointDescriptor i0_endpoint_descriptor = {
  0E00 07               DB 007h                 ;   byte bLength = 7;
  0E01 05               DB 005h                 ;   byte bDescriptorType = ENDPOINT;
  0E02 81               DB 081h                 ;   byte bEndpointAddress = 0x81; // IN | 1
  0E03 03               DB 003h                 ;   byte bmAttributes = 3; // Interrupt
  0E04 08               DB 008h
  0E05 00               DB 000h                 ;   word wMaxPacketSize = 8;
  0E06 0A               DB 00Ah                 ;   byte bInterval = 10;
                                                ;};
                                                ;struct InterfaceDescriptor interface_descriptor_1 = {
  0E07 09               DB 009h                 ;   byte bLength = 9;
  0E08 04               DB 004h                 ;   byte bDescriptorType = INTERFACE;
  0E09 01               DB 001h                 ;   byte bInterfaceNumber = 1;
  0E0A 00               DB 000h                 ;   byte bAlternateSetting = 0;
  0E0B 01               DB 001h                 ;   byte bNumEndpoints = 1;
  0E0C 03               DB 003h                 ;   byte bInterfaceClass = HID_CLASS;
  0E0D 00               DB 000h                 ;   byte bInterfaceSubclass = 0;
  0E0E 00               DB 000h                 ;   byte bInterfaceProtocol = 0;
  0E0F 00               DB 000h                 ;   byte iInterface = 0; // no string
                                                ;};
                                                ;struct HidDescriptor i1_hid_descriptor = {
  0E10 09               DB 009h                 ;   byte bLength = 9;
  0E11 21               DB 021h                 ;   byte bDescriptorType = HID;
  0E12 11               DB 011h
  0E13 01               DB 001h                 ;   word bcdHID = 0x0111, 1.11;
  0E14 00               DB 000h                 ;   byte bCountryCode = 0, not supported;
  0E15 01               DB 001h                 ;   byte bNumDescriptors = 1;
  0E16 22               DB 022h                 ;   byte bDescriptorType = 0x22, REPORT;
  0E17 58               DB 058h                 ;   word wDescriptorLength = 0x58;
  0E18 00               DB 000h
                                                ;};
                                                ;struct EndpointDescriptor i1_endpoint_descriptor = {
  0E19 07               DB 007h                 ;   byte bLength = 7;
  0E1A 05               DB 005h                 ;   byte bDescriptorType = ENDPOINT;
  0E1B 82               DB 082h                 ;   byte bEndpointAddress = 0x82; // IN | 2
  0E1C 03               DB 003h                 ;   byte bmAttributes = 3; // Interrupt
  0E1D 08               DB 008h
  0E1E 00               DB 000h                 ;   word wMaxPacketSize = 8;
  0E1F 0A               DB 00Ah                 ;   byte bInterval = 10;
                                                ;};
isp_reprogram:                                  ;void isp_reprogram(byte __register(R7) size /*always 0x40*/) {
  0E20 7865             MOV R0, #65h
  0E22 EF               MOV A, R7
  0E23 F2               MOVX @R0, A             ;   X65 = size; // 0x40
  0E24 780A             MOV R0, #0Ah
  0E26 E2               MOVX A, @R0
  0E27 7035             JNZ L0314               ;   if (isp_state == 0) {
  0E29 7817             MOV R0, #17h
  0E2B E2               MOVX A, @R0
  0E2C FF               MOV R7, A
  0E2D 780A             MOV R0, #0Ah
  0E2F F2               MOVX @R0, A             ;       isp_state = request.bmRequestType;
  0E30 2489             ADD A, #89h
  0E32 6009             JZ L0315                ;       switch (request.bmRequestType) {
  0E34 2411             ADD A, #11h
  0E36 6003             JZ L0316
  0E38 020EF3           LJMP L0317

L0316:
  0E3B 8010             SJMP L0318

L0315:                                          ;       case 0x77: // Host-to-device, Reserved, Reserved
  0E3D 780D             MOV R0, #0Dh
  0E3F 7428             MOV A, #28h
  0E41 F2               MOVX @R0, A
  0E42 08               INC R0
  0E43 E4               CLR A
  0E44 F2               MOVX @R0, A             ;           isp_ptr = &macros;
  0E45 7812             MOV R0, #12h
  0E47 7408             MOV A, #8h
  0E49 F2               MOVX @R0, A             ;           LOBYTE(isp_count) = 8;
  0E4A 1219F1           LCALL isp_erase_pages   ;           isp_erase_pages(); // 8 pages at [0x2800, 0x3800)
                                                ;           // fallthrough;
L0318:                                          ;       case 0x66: // Host-to-device, Reserved, Reserved
  0E4D 780D             MOV R0, #0Dh
  0E4F 7428             MOV A, #28h
  0E51 F2               MOVX @R0, A
  0E52 08               INC R0
  0E53 E4               CLR A
  0E54 F2               MOVX @R0, A             ;           isp_ptr = &macros;
  0E55 7811             MOV R0, #11h
  0E57 7410             MOV A, #10h
  0E59 F2               MOVX @R0, A
  0E5A 08               INC R0
  0E5B E4               CLR A
  0E5C F2               MOVX @R0, A             ;           LOWORD(isp_count) = 0x1000;
  0E5D 22               RET                     ;           return;
                                                ;       default: return;
L0314:                                          ;   }   }
  0E5E 7865             MOV R0, #65h
  0E60 E2               MOVX A, @R0
  0E61 24FE             ADD A, #0FEh
  0E63 F2               MOVX @R0, A             ;   X65 -= 2; // r7 - 2
  0E64 E2               MOVX A, @R0
  0E65 FF               MOV R7, A
  0E66 E4               CLR A
  0E67 FC               MOV R4, A
  0E68 FD               MOV R5, A
  0E69 FE               MOV R6, A
  0E6A 780F             MOV R0, #0Fh
  0E6C E2               MOVX A, @R0
  0E6D FB               MOV R3, A
  0E6E 08               INC R0
  0E6F E2               MOVX A, @R0
  0E70 F9               MOV R1, A
  0E71 08               INC R0
  0E72 E2               MOVX A, @R0
  0E73 FA               MOV R2, A
  0E74 08               INC R0
  0E75 E2               MOVX A, @R0
  0E76 CB               XCH A, R3
  0E77 F8               MOV R0, A
  0E78 D3               SETB C
  0E79 121026           LCALL dword_compare
  0E7C 500A             JNC L0322               ;   if (X65 + 1 /*r7 - 1*/ > isp_count) { // dword_compare(isp_count, 0:0:0:X65, true)
  0E7E 7812             MOV R0, #12h
  0E80 E2               MOVX A, @R0
  0E81 7865             MOV R0, #65h
  0E83 F2               MOVX @R0, A             ;       X65 = isp_count;
  0E84 E4               CLR A
  0E85 780A             MOV R0, #0Ah
  0E87 F2               MOVX @R0, A             ;       isp_state = 0;
L0322:                                          ;   }
  0E88 780F             MOV R0, #0Fh
  0E8A E2               MOVX A, @R0
  0E8B FC               MOV R4, A
  0E8C 08               INC R0
  0E8D E2               MOVX A, @R0
  0E8E FD               MOV R5, A
  0E8F 08               INC R0
  0E90 E2               MOVX A, @R0
  0E91 FE               MOV R6, A
  0E92 08               INC R0
  0E93 E2               MOVX A, @R0
  0E94 FF               MOV R7, A
  0E95 EF               MOV A, R7
  0E96 C0E0             PUSH ACC
  0E98 7865             MOV R0, #65h
  0E9A E2               MOVX A, @R0
  0E9B FB               MOV R3, A
  0E9C D0E0             POP ACC
  0E9E FF               MOV R7, A
  0E9F C3               CLR C
  0EA0 EF               MOV A, R7
  0EA1 9B               SUBB A, R3
  0EA2 FF               MOV R7, A
  0EA3 EE               MOV A, R6
  0EA4 9400             SUBB A, #0h
  0EA6 FE               MOV R6, A
  0EA7 ED               MOV A, R5
  0EA8 9400             SUBB A, #0h
  0EAA FD               MOV R5, A
  0EAB EC               MOV A, R4
  0EAC 9400             SUBB A, #0h
  0EAE FC               MOV R4, A
  0EAF 780F             MOV R0, #0Fh
  0EB1 121037           LCALL dword_write       ;   isp_count = isp_count - X65; // dword_write(0x0F, isp_count - X65)

  0EB4 E4               CLR A
  0EB5 7813             MOV R0, #13h
  0EB7 F2               MOVX @R0, A
L0323:
  0EB8 7865             MOV R0, #65h
  0EBA E2               MOVX A, @R0
  0EBB FF               MOV R7, A
  0EBC 7813             MOV R0, #13h
  0EBE E2               MOVX A, @R0
  0EBF FE               MOV R6, A
  0EC0 C3               CLR C
  0EC1 9F               SUBB A, R7
  0EC2 502F             JNC L0317               ;   for (byte __volatile(X13) i = 0; i < X65; ++i) {
  0EC4 7419             MOV A, #19h
  0EC6 2E               ADD A, R6
  0EC7 F8               MOV R0, A
  0EC8 E2               MOVX A, @R0
  0EC9 FD               MOV R5, A
  0ECA 7F02             MOV R7, #2h
  0ECC 1219A3           LCALL isp               ;       isp(IspModeWrite, ((byte*)(&request)+2)[i]);
  0ECF 780B             MOV R0, #0Bh
  0ED1 E2               MOVX A, @R0
  0ED2 FC               MOV R4, A
  0ED3 08               INC R0
  0ED4 E2               MOVX A, @R0
  0ED5 FD               MOV R5, A
  0ED6 08               INC R0
  0ED7 E2               MOVX A, @R0
  0ED8 FE               MOV R6, A
  0ED9 08               INC R0
  0EDA E2               MOVX A, @R0
  0EDB 2401             ADD A, #1h
  0EDD FF               MOV R7, A
  0EDE E4               CLR A
  0EDF 3E               ADDC A, R6
  0EE0 FE               MOV R6, A
  0EE1 E4               CLR A
  0EE2 3D               ADDC A, R5
  0EE3 FD               MOV R5, A
  0EE4 E4               CLR A
  0EE5 3C               ADDC A, R4
  0EE6 FC               MOV R4, A
  0EE7 780B             MOV R0, #0Bh
  0EE9 121037           LCALL dword_write       ;       isp_ptr = isp_ptr + 1; // dword_write(0x0B, isp_ptr + 1)
  0EEC 7813             MOV R0, #13h
  0EEE E2               MOVX A, @R0
  0EEF 04               INC A
  0EF0 F2               MOVX @R0, A
  0EF1 80C5             SJMP L0323              ;   }
L0317:
  0EF3 22               RET                     ;}

do_transmit:                                    ;void do_transmit() {
  0EF4 7816             MOV R0, #16h
  0EF6 E2               MOVX A, @R0
  0EF7 645A             XRL A, #5Ah
  0EF9 7049             JNZ L0268               ;   if (request_state == 0x5A) {
  0EFB 785B             MOV R0, #5Bh
  0EFD E2               MOVX A, @R0
  0EFE FF               MOV R7, A
  0EFF FD               MOV R5, A
  0F00 08               INC R0
  0F01 E2               MOVX A, @R0
  0F02 FA               MOV R2, A
  0F03 08               INC R0
  0F04 E2               MOVX A, @R0
  0F05 FB               MOV R3, A
  0F06 D3               SETB C
  0F07 9D               SUBB A, R5
  0F08 EA               MOV A, R2
  0F09 9400             SUBB A, #0h
  0F0B 7864             MOV R0, #64h            ;       byte __volatile(X64) count;
  0F0D 4004             JC L0269                ;       if (tx_rx_count >= max_transmit + 1) {
  0F0F EF               MOV A, R7
  0F10 F2               MOVX @R0, A             ;           count = max_transmit;
  0F11 8002             SJMP L0270

L0269:                                          ;       } else {
  0F13 EB               MOV A, R3
  0F14 F2               MOVX @R0, A             ;           count = LOBYTE(tx_rx_count);
L0270:                                          ;       }
  0F15 7857             MOV R0, #57h
  0F17 E2               MOVX A, @R0
  0F18 FB               MOV R3, A
  0F19 08               INC R0
  0F1A E2               MOVX A, @R0
  0F1B FA               MOV R2, A
  0F1C 08               INC R0
  0F1D E2               MOVX A, @R0
  0F1E F9               MOV R1, A
  0F1F 7864             MOV R0, #64h
  0F21 E2               MOVX A, @R0
  0F22 FD               MOV R5, A
  0F23 121978           LCALL transmit          ;       transmit(transmit_addr_mode, to_transmit, count);
  0F26 7864             MOV R0, #64h
  0F28 E2               MOVX A, @R0
  0F29 FF               MOV R7, A
  0F2A 90FFF6           MOV DPTR, #0FFF6h
  0F2D F0               MOVX @DPTR, A           ;       TXCNT = count;
  0F2E 7E00             MOV R6, #0h
  0F30 C3               CLR C
  0F31 785D             MOV R0, #5Dh
  0F33 E2               MOVX A, @R0
  0F34 9F               SUBB A, R7
  0F35 F2               MOVX @R0, A
  0F36 18               DEC R0
  0F37 E2               MOVX A, @R0
  0F38 9E               SUBB A, R6
  0F39 F2               MOVX @R0, A             ;       tx_rx_count -= count;
  0F3A 7859             MOV R0, #59h
  0F3C E2               MOVX A, @R0
  0F3D 2F               ADD A, R7
  0F3E F2               MOVX @R0, A
  0F3F 18               DEC R0
  0F40 E2               MOVX A, @R0
  0F41 3E               ADDC A, R6
  0F42 F2               MOVX @R0, A             ;       to_transmit += count;
  0F43 22               RET                     ;       return;
L0268:                                          ;   }
  0F44 7816             MOV R0, #16h
  0F46 E2               MOVX A, @R0
  0F47 6422             XRL A, #22h
  0F49 7050             JNZ L0278               ;   if (request_state == 0x22) {
  0F4B 785B             MOV R0, #5Bh
  0F4D E2               MOVX A, @R0
  0F4E FF               MOV R7, A
  0F4F FD               MOV R5, A
  0F50 08               INC R0
  0F51 E2               MOVX A, @R0
  0F52 FA               MOV R2, A
  0F53 08               INC R0
  0F54 E2               MOVX A, @R0
  0F55 FB               MOV R3, A
  0F56 D3               SETB C
  0F57 9D               SUBB A, R5
  0F58 EA               MOV A, R2
  0F59 9400             SUBB A, #0h
  0F5B 7864             MOV R0, #64h            ;       byte __volatile(X64) count;
  0F5D 4004             JC L0279                ;       if (tx_rx_count >= max_transmit + 1) {
  0F5F EF               MOV A, R7
  0F60 F2               MOVX @R0, A             ;           count = max_transmit;
  0F61 8002             SJMP L0280

L0279:                                          ;       } else {
  0F63 EB               MOV A, R3
  0F64 F2               MOVX @R0, A             ;           count = LOBYTE(tx_rx_count);
L0280:                                          ;       }
  0F65 7864             MOV R0, #64h
  0F67 E2               MOVX A, @R0
  0F68 B44005           CJNE A, #40h, L0281     ;       if (count == 0x40) {
  0F6B 1212B6           LCALL isp_read_block    ;           isp_read_block();
  0F6E 800A             SJMP L0283
L0281:                                          ;       } else
  0F70 7864             MOV R0, #64h
  0F72 E2               MOVX A, @R0
  0F73 6005             JZ L0283                ;       if (count != 0) {
  0F75 7817             MOV R0, #17h
  0F77 E520             MOV A, 20h
  0F79 F2               MOVX @R0, A             ;           report[0] = 0x20;
L0283:                                          ;       }
  0F7A 7BFE             MOV R3, #0FEh
  0F7C 7A00             MOV R2, #0h
  0F7E 7917             MOV R1, #17h
  0F80 7864             MOV R0, #64h
  0F82 E2               MOVX A, @R0
  0F83 FD               MOV R5, A
  0F84 121978           LCALL transmit          ;       transmit(0xFE, &report, count);
  0F87 7864             MOV R0, #64h
  0F89 E2               MOVX A, @R0
  0F8A FF               MOV R7, A
  0F8B 90FFF6           MOV DPTR, #0FFF6h
  0F8E F0               MOVX @DPTR, A           ;       TXCNT = count;
  0F8F C3               CLR C
  0F90 785D             MOV R0, #5Dh
  0F92 E2               MOVX A, @R0
  0F93 9F               SUBB A, R7
  0F94 F2               MOVX @R0, A
  0F95 18               DEC R0
  0F96 E2               MOVX A, @R0
  0F97 9400             SUBB A, #0h
  0F99 F2               MOVX @R0, A             ;       tx_rx_count -= count;
  0F9A 22               RET                     ;       return;

L0278:                                          ;   }
  0F9B 90FFE1           MOV DPTR, #0FFE1h
  0F9E E0               MOVX A, @DPTR
  0F9F 44C0             ORL A, #0C0h
  0FA1 F0               MOVX @DPTR, A           ;   EPCON.RXSTL = EPCON.TXSTL = true;
  0FA2 7816             MOV R0, #16h
  0FA4 E2               MOVX A, @R0
  0FA5 B45507           CJNE A, #55h, L0294     ;   if (request_state == 0x55) {
  0FA8 785E             MOV R0, #5Eh
  0FAA E2               MOVX A, @R0
  0FAB 90FFD8           MOV DPTR, #0FFD8h
  0FAE F0               MOVX @DPTR, A           ;       UADDR = usb_address;
L0294:                                          ;   }
  0FAF 780A             MOV R0, #0Ah
  0FB1 E2               MOVX A, @R0
  0FB2 B44408           CJNE A, #44h, L0295     ;   if (isp_state == 0x44
  0FB5 30EB05           JNB 0EBh, L0295         ;       and P4.3) {
  0FB8 7F68             MOV R7, #68h
  0FBA 120065           LCALL set_ISPCR         ;       set_ISPCR(SBWS | SWRST | MISPF); // software reset, boot from ISP, Megawin
L0295:                                          ;   }
  0FBD 22               RET                     ;}

byte_read:                                      ;byte __register(A) byte_read(R3 == 1,    byte* __register(R2:R1) Xptr)
                                                ;               or  byte_read(R3 == 0,    byte* __register(R1) ptr)
                                                ;               or  byte_read(R3 == 0xFE, byte* __register(R1) Xptr)
                                                ;               or  byte_read(R3 == *,    byte* __register(R2:R1) Cptr)
                                                ;{
  0FBE BB0106           CJNE R3, #1h, L0371     ;   if (mode == 1) {
  0FC1 8982             MOV DPL, R1
  0FC3 8A83             MOV DPH, R2
  0FC5 E0               MOVX A, @DPTR
  0FC6 22               RET                     ;       return *Xptr;

L0371:                                          ;   } else
  0FC7 5002             JNC L0372               ;   if (mode < 1) {
  0FC9 E7               MOV A, @R1              ;       return *ptr;
  0FCA 22               RET

L0372:                                          ;   } else
  0FCB BBFE02           CJNE R3, #0FEh, L0373   ;   if (mode == 0xFE) {
  0FCE E3               MOVX A, @R1             ;       return *Xptr;
  0FCF 22               RET

L0373:                                          ;   } else {
  0FD0 8982             MOV DPL, R1
  0FD2 8A83             MOV DPH, R2
  0FD4 E4               CLR A
  0FD5 93               MOVC A, @A+DPTR         ;       return *Cptr;
  0FD6 22               RET                     ;}  }

memread:                                        ;byte __register(A) memread(R3 == 1,  byte* __register(DPH:DPL) Xbase16, word __register(R2:R1) offset16)
                                                ;                   or   (R3 == 0,    byte* __register(DPL)     base8,   byte __register(R1) offset8)
                                                ;                   or   (R3 == 0xFE, byte* __register(DPL)     Xbase8,  byte __register(R1) offset8)
                                                ;                   or   (R3 == *,    byte* __register(DPH:DPL) Cbase16, byte __register(R2:R1) offset16)
                                                ;{
  0FD7 BB010C           CJNE R3, #1h, L0275     ;   if (mode == 1) {
  0FDA E582             MOV A, DPL
  0FDC 29               ADD A, R1
  0FDD F582             MOV DPL, A
  0FDF E583             MOV A, DPH
  0FE1 3A               ADDC A, R2
  0FE2 F583             MOV DPH, A
  0FE4 E0               MOVX A, @DPTR
  0FE5 22               RET                     ;       return Xbase16[offset16];

L0275:                                          ;   }
  0FE6 5006             JNC L0276               ;   else if (mode < 1) {
  0FE8 E9               MOV A, R1
  0FE9 2582             ADD A, DPL
  0FEB F8               MOV R0, A
  0FEC E6               MOV A, @R0              ;       return base8[offset8];
  0FED 22               RET

L0276:                                          ;   }
  0FEE BBFE06           CJNE R3, #0FEh, L0277   ;   else if (mode == 0xFE) {
  0FF1 E9               MOV A, R1
  0FF2 2582             ADD A, DPL
  0FF4 F8               MOV R0, A
  0FF5 E2               MOVX A, @R0             ;       return Xbase8[offset8];
  0FF6 22               RET

L0277:                                          ;   } else {
  0FF7 E582             MOV A, DPL
  0FF9 29               ADD A, R1
  0FFA F582             MOV DPL, A
  0FFC E583             MOV A, DPH
  0FFE 3A               ADDC A, R2
  0FFF F583             MOV DPH, A
  1001 E4               CLR A
  1002 93               MOVC A, @A+DPTR         ;       return Cbase16[offset16]
  1003 22               RET                     ;}  }

memwrite:                                       ;void memwrite(R3 == 1,    byte* __register(DPTR) Xbase16, word __register(R2:R1) offset16, byte __register(A) value)
                                                ;       or    (R3 == 0,    byte* __register(DPL)  base8,   byte __register(R1)    offset8,  byte __register(A) value)
                                                ;       or    (R3 == 0xFE, byte* __register(DPL)  Xbase8,  byte __register(R1)    offset8,  byte __register(A) value)
                                                ;{
  1004 F8               MOV R0, A
  1005 BB010D           CJNE R3, #1h, L0306     ;   if (mode == 1) {
  1008 E582             MOV A, DPL
  100A 29               ADD A, R1
  100B F582             MOV DPL, A
  100D E583             MOV A, DPH
  100F 3A               ADDC A, R2
  1010 F583             MOV DPH, A
  1012 E8               MOV A, R0
  1013 F0               MOVX @DPTR, A           ;       Xbase16[offset16] = value;
  1014 22               RET

L0306:                                          ;   }
  1015 5006             JNC L0307               ;   else if (mode < 1) {
  1017 E9               MOV A, R1
  1018 2582             ADD A, DPL
  101A C8               XCH A, R0
  101B F6               MOV @R0, A              ;       base8[offset8] = value;
  101C 22               RET

L0307:                                          ;   }
  101D BBFE05           CJNE R3, #0FEh, L0308   ;   else if (mode == 0xFE) {
  1020 E9               MOV A, R1
  1021 2582             ADD A, DPL
  1023 C8               XCH A, R0
  1024 F2               MOVX @R0, A             ;       Xbase8[offset8] = value;
L0308:                                          ;   }
  1025 22               RET                     ;}

dword_compare:                                  ;{bool __register(C), // true if lhs <  rhs + carry
                                                ; byte __register(A)} // 0    if lhs == rhs + carry
                                                ;dword_compare(dword __register(R0:R1:R2:R3) lhs,
                                                ;              dword __register(R4:R5:R6:R7) rhs,
                                                ;              bool __register(C) carry)
  1026 EB               MOV A, R3               ;{
  1027 9F               SUBB A, R7
  1028 F5F0             MOV B, A
  102A EA               MOV A, R2
  102B 9E               SUBB A, R6
  102C 42F0             ORL B, A
  102E E9               MOV A, R1
  102F 9D               SUBB A, R5
  1030 42F0             ORL B, A
  1032 E8               MOV A, R0
  1033 9C               SUBB A, R4              ;   dword j:k:l:m = lhs - rhs - carry;
  1034 45F0             ORL A, B                ;   return j | k | l | m;
  1036 22               RET                     ;}

dword_write:                                    ;void dword_write(dword* __register(R0) p, dword __register(R4:R5:R6:R7) value) {
  1037 EC               MOV A, R4
  1038 F2               MOVX @R0, A
  1039 08               INC R0
  103A ED               MOV A, R5
  103B F2               MOVX @R0, A
  103C 08               INC R0
  103D EE               MOV A, R6
  103E F2               MOVX @R0, A
  103F 08               INC R0
  1040 EF               MOV A, R7
  1041 F2               MOVX @R0, A             ;   *p = value;
  1042 22               RET                     ;}

mov_dword:                                      ;void mov_dword(dword* __register(R0) Xptr) {
  1043 D083             POP DPH
  1045 D082             POP DPL                 ;   DPTR = return_ip;
  1047 E4               CLR A
  1048 93               MOVC A, @A+DPTR
  1049 F2               MOVX @R0, A
  104A 08               INC R0                  ;   *Xptr++ = C:DPTR[0];
  104B 7401             MOV A, #1h
  104D 93               MOVC A, @A+DPTR
  104E F2               MOVX @R0, A
  104F 08               INC R0                  ;   *Xptr++ = C:DPTR[1];
  1050 7402             MOV A, #2h
  1052 93               MOVC A, @A+DPTR
  1053 F2               MOVX @R0, A
  1054 08               INC R0                  ;   *Xptr++ = C:DPTR[2];
  1055 7403             MOV A, #3h
  1057 93               MOVC A, @A+DPTR
  1058 F2               MOVX @R0, A             ;   *Xptr = C:DPTR[3];
  1059 7404             MOV A, #4h
  105B 73               JMP @A+DPTR             ;   return at DPTR+4;
                                                ;}

memset:                                         ;void memset(R6 == R7 == 0) // nop
                                                ;  or memset(R3 == 1, byte* __register(R2:R1) Xptr, byte __register(R6) size, R7 == 0, byte __register(R5) value) // fill size × 256 bytes at Xptr with value
                                                ;  or memset(R3 == 1, byte* __register(R2:R1) Xptr, byte __register(R6) r6, byte __register(R7) r7, byte __register(R5) value) // fill r6+1 × r7 bytes at Xptr with value
                                                ;  or memset(R3 == 0, byte* __register(R1) ptr, byte __register(R7) size, byte __register(R5) value) // fill size bytes at ptr with value
                                                ;  or memset(R3 == 0xFE, byte* __register(R1) Xptr, byte __register(R7) size, byte __register(R5) value) // fill size bytes at Xptr with value
                                                ;{
  105C EF               MOV A, R7
  105D 4E               ORL A, R6
  105E 6012             JZ L0029                ;   if (r6 == 0 && r7 == 0) return;
  1060 EF               MOV A, R7
  1061 6001             JZ L0030                ;   if (r7 != 0)
  1063 0E               INC R6                  ;       R6 = r6 + 1;
L0030:
  1064 ED               MOV A, R5
  1065 BB010B           CJNE R3, #1h, L0031     ;   if (r3 == 1) {
  1068 8982             MOV DPL, R1
  106A 8A83             MOV DPH, R2
L0032:                                          ;       while (R6 --> 0) while (r7 --> 0) {
  106C F0               MOVX @DPTR, A
  106D A3               INC DPTR                ;           *Xptr++ = value;
  106E DFFC             DJNZ R7, L0032
  1070 DEFA             DJNZ R6, L0032          ;       }
L0029:
  1072 22               RET                     ;       return;

L0031:                                          ;   } else
  1073 89F0             MOV B, R1
  1075 5007             JNC L0033               ;   if (r3 < 1) {
L0034:                                          ;       while (r7 --> 0) {
  1077 F7               MOV @R1, A
  1078 09               INC R1                  ;           *ptr++ = value;
  1079 DFFC             DJNZ R7, L0034          ;       }
  107B A9F0             MOV R1, B
L0035:
  107D 22               RET                     ;       return;

L0033:                                          ;   }
  107E BBFEFC           CJNE R3, #0FEh, L0035   ;   if (r3 == 0xFE) {
L0036:                                          ;       while (r7 --> 0) {
  1081 F3               MOVX @R1, A
  1082 09               INC R1                  ;           *Xptr++ = value;
  1083 DFFC             DJNZ R7, L0036          ;       }
  1085 A9F0             MOV R1, B
  1087 22               RET                     ;}  }

do_receive:                                     ;void do_receive() {
                                                ;   byte __volatile(X64) count;
  1088 90FFF4           MOV DPTR, #0FFF4h
  108B 7480             MOV A, #80h
  108D F0               MOVX @DPTR, A           ;   TXCON = TXCLR;
  108E 90FFE2           MOV DPTR, #0FFE2h
  1091 E0               MOVX A, @DPTR
  1092 5430             ANL A, #30h
  1094 6053             JZ L0298                ;   if (RXSTAT.STOVW or RXSTAT.EDOVW) {
  1096 7816             MOV R0, #16h
  1098 74F0             MOV A, #0F0h
  109A F2               MOVX @R0, A             ;       request_state = 0xF0;
L0299:                                          ;       do {do {
  109B 90FFE2           MOV DPTR, #0FFE2h
  109E E0               MOVX A, @DPTR
  109F 20E5F9           JB ACC.5, L0299         ;           } while (RXSTAT.STOVW);
L0300:                                          ;           do {
  10A2 90FFE2           MOV DPTR, #0FFE2h
  10A5 E0               MOVX A, @DPTR
  10A6 30E4F9           JNB ACC.4, L0300        ;           } while (not RXSTAT.EDOVW);
  10A9 90FFE2           MOV DPTR, #0FFE2h
  10AC E0               MOVX A, @DPTR
  10AD 54EF             ANL A, #0EFh
  10AF F0               MOVX @DPTR, A           ;           RXSTAT.EDOVW = false; // to read FIFO
  10B0 90FFDB           MOV DPTR, #0FFDBh
  10B3 7402             MOV A, #2h
  10B5 F0               MOVX @DPTR, A           ;           UIFLG = URXD0;
  10B6 90FFE6           MOV DPTR, #0FFE6h
  10B9 E0               MOVX A, @DPTR
  10BA 7864             MOV R0, #64h
  10BC F2               MOVX @R0, A             ;           count = RXCNT;
  10BD 7BFE             MOV R3, #0FEh
  10BF 7A00             MOV R2, #0h
  10C1 7917             MOV R1, #17h
  10C3 E2               MOVX A, @R0
  10C4 FD               MOV R5, A
  10C5 12194B           LCALL receive           ;           receive(0xFE, &request, count);
  10C8 90FFE2           MOV DPTR, #0FFE2h
  10CB E0               MOVX A, @DPTR
  10CC 5430             ANL A, #30h
  10CE 70CB             JNZ L0299               ;       } while (RXSTAT.STOVW or RXSTAT.EDOVW);
  10D0 90FFE1           MOV DPTR, #0FFE1h
  10D3 E0               MOVX A, @DPTR
  10D4 543F             ANL A, #3Fh
  10D6 F0               MOVX @DPTR, A           ;       EPCON.RXSTL = EPCON.TXSTL = false;
  10D7 A3               INC DPTR
  10D8 E0               MOVX A, @DPTR
  10D9 54BF             ANL A, #0BFh
  10DB F0               MOVX @DPTR, A           ;       RXSTAT.RXSETUP = false;
  10DC 7864             MOV R0, #64h
  10DE E2               MOVX A, @R0
  10DF FF               MOV R7, A
  10E0 785C             MOV R0, #5Ch
  10E2 E4               CLR A
  10E3 F2               MOVX @R0, A
  10E4 08               INC R0
  10E5 EF               MOV A, R7
  10E6 F2               MOVX @R0, A             ;       tx_rx_count = count;
  10E7 805C             SJMP L0302

L0298:                                          ;   } else {
  10E9 7816             MOV R0, #16h
  10EB E2               MOVX A, @R0
  10EC 6433             XRL A, #33h
  10EE 7049             JNZ L0309               ;       if (request_state == 0x33) {
  10F0 90FFE6           MOV DPTR, #0FFE6h
  10F3 E0               MOVX A, @DPTR
  10F4 7864             MOV R0, #64h
  10F6 F2               MOVX @R0, A             ;           count = RXCNT;
  10F7 E2               MOVX A, @R0
  10F8 FF               MOV R7, A
  10F9 C3               CLR C
  10FA 785D             MOV R0, #5Dh
  10FC E2               MOVX A, @R0
  10FD 9F               SUBB A, R7
  10FE F2               MOVX @R0, A
  10FF 18               DEC R0
  1100 E2               MOVX A, @R0
  1101 9400             SUBB A, #0h
  1103 F2               MOVX @R0, A             ;           tx_rx_count -= count;
  1104 7BFE             MOV R3, #0FEh
  1106 7A00             MOV R2, #0h
  1108 7917             MOV R1, #17h
  110A 7864             MOV R0, #64h
  110C E2               MOVX A, @R0
  110D FD               MOV R5, A
  110E 12194B           LCALL receive           ;           receive(XRAM_8, &request, count);
  1111 7864             MOV R0, #64h
  1113 E2               MOVX A, @R0
  1114 FF               MOV R7, A
  1115 B44005           CJNE A, #40h, L0310     ;           if (count == 0x40) { // 64 bytes?
  1118 120E20           LCALL isp_reprogram     ;               isp_reprogram(count);
  111B 8008             SJMP L0312

L0310:                                          ;           } else {
  111D 7817             MOV R0, #17h
  111F E2               MOVX A, @R0
  1120 F520             MOV 20h, A              ;               led_state = request[0];
  1122 121AB0           LCALL upd_leds          ;               upd_leds();
L0312:                                          ;           }
  1125 785D             MOV R0, #5Dh
  1127 E2               MOVX A, @R0
  1128 7002             JNZ L0313
  112A 18               DEC R0
  112B E2               MOVX A, @R0
L0313:
  112C 7017             JNZ L0302               ;           if (tx_rx_count != 0) {
                                                ;               RXCON.RXFFRC = true;
                                                ;               return;
                                                ;           }
  112E 90FFF6           MOV DPTR, #0FFF6h
  1131 F0               MOVX @DPTR, A           ;           TXCNT = 0;
  1132 7816             MOV R0, #16h
  1134 74A5             MOV A, #0A5h
  1136 F2               MOVX @R0, A             ;           request_state = 0xA5;
  1137 800C             SJMP L0302              ;           RXCON.RXFFRC = true; return;

L0309:                                          ;       }
  1139 7816             MOV R0, #16h
  113B 74A5             MOV A, #0A5h
  113D F2               MOVX @R0, A             ;       request_state = 0xA5;
  113E 90FFE1           MOV DPTR, #0FFE1h
  1141 E0               MOVX A, @DPTR
  1142 44C0             ORL A, #0C0h
  1144 F0               MOVX @DPTR, A           ;       EPCON.RXSTL = EPCON.TXSTL = true;
L0302:                                          ;   }
  1145 90FFE4           MOV DPTR, #0FFE4h
  1148 E0               MOVX A, @DPTR
  1149 4410             ORL A, #10h
  114B F0               MOVX @DPTR, A           ;   RXCON.RXFFRC = true;
  114C 22               RET                     ;}

standard_request:                               ;void standard_request() {
  114D 7818             MOV R0, #18h
  114F E2               MOVX A, @R0
  1150 B40D00           CJNE A, #0Dh, L0254
L0254:
  1153 4003             JC L0255                ;   switch (request.bRequest) {
  1155 021200           LJMP L0256
L0255:
  1158 90115F           MOV DPTR, #0115Fh
  115B F8               MOV R0, A
  115C 28               ADD A, R0
  115D 28               ADD A, R0
  115E 73               JMP @A+DPTR
  115F 021186           LJMP L0334
  1162 021190           LJMP L0344
  1165 021200           LJMP L0256
  1168 02119A           LJMP L0352
  116B 021200           LJMP L0256
  116E 0211A4           LJMP L0359
  1171 0211B1           LJMP L0360
  1174 021200           LJMP L0256
  1177 0211BB           LJMP L0389
  117A 0211CF           LJMP L0390
  117D 0211E5           LJMP L0396
  1180 0211DD           LJMP L0400
  1183 0211F0           LJMP L0405

L0334:                                          ;   case 0: // GET_STATUS
  1186 7816             MOV R0, #16h
  1188 745A             MOV A, #5Ah
  118A F2               MOVX @R0, A             ;       request_state = 0x5A;
  118B 12000E           LCALL get_status        ;       get_status();
  118E 805D             SJMP L0336              ;       do_transmit(); return;

L0344:                                          ;   case 1: // CLEAR_FEATURE
  1190 7816             MOV R0, #16h
  1192 74A5             MOV A, #0A5h
  1194 F2               MOVX @R0, A             ;       request_state = 0xA5;
  1195 121735           LCALL clear_feature     ;       clear_feature();
  1198 803D             SJMP L0346              ;       TXCNT = 0; return;

L0352:                                          ;   case 3: // SET_FEATURE
  119A 7816             MOV R0, #16h
  119C 74A5             MOV A, #0A5h
  119E F2               MOVX @R0, A             ;       request_state = 0xA5;
  119F 1217C3           LCALL set_feature       ;       set_feature();
  11A2 8033             SJMP L0346              ;       TXCNT = 0; return;

L0359:                                          ;   case 5: // SET_ADDRESS
  11A4 7816             MOV R0, #16h
  11A6 7455             MOV A, #55h
  11A8 F2               MOVX @R0, A             ;       request_state = 0x55;
  11A9 7819             MOV R0, #19h
  11AB E2               MOVX A, @R0
  11AC 785E             MOV R0, #5Eh
  11AE F2               MOVX @R0, A             ;       usb_address = LOBYTE(request.wValue);
  11AF 8026             SJMP L0346              ;       TXCNT = 0; return;

L0360:                                          ;   case 6: // GET_DESCRIPTOR
  11B1 7816             MOV R0, #16h
  11B3 745A             MOV A, #5Ah
  11B5 F2               MOVX @R0, A             ;       request_state = 0x5A;
  11B6 1205C3           LCALL get_descriptor    ;       get_descriptor();
  11B9 8032             SJMP L0336              ;       do_transmit(); return;

L0389:                                          ;   case 8: // GET_CONFIGURATION
  11BB 7816             MOV R0, #16h
  11BD 745A             MOV A, #5Ah
  11BF F2               MOVX @R0, A             ;       request_state = 0x5A;
  11C0 785E             MOV R0, #5Eh
  11C2 E2               MOVX A, @R0
  11C3 7817             MOV R0, #17h
  11C5 F2               MOVX @R0, A             ;       report[0] = usb_configuration;
  11C6 785C             MOV R0, #5Ch
  11C8 E4               CLR A
  11C9 F2               MOVX @R0, A
  11CA 08               INC R0
  11CB 04               INC A
  11CC F2               MOVX @R0, A             ;       tx_rx_count = 1;
  11CD 801E             SJMP L0336              ;       do_transmit(); return;

L0390:                                          ;   case 9: // SET_CONFIGURATION
  11CF 7816             MOV R0, #16h
  11D1 74A5             MOV A, #0A5h
  11D3 F2               MOVX @R0, A             ;       request_state = 0xA5;
  11D4 1216E9           LCALL set_configuration ;       set_configuration();
L0346:
  11D7 90FFF6           MOV DPTR, #0FFF6h
  11DA E4               CLR A
  11DB F0               MOVX @DPTR, A           ;       TXCNT = 0;
  11DC 22               RET                     ;       return;

L0400:                                          ;   case 0x0B: // SET_INTERFACE
  11DD 7816             MOV R0, #16h
  11DF 74A5             MOV A, #0A5h
  11E1 F2               MOVX @R0, A             ;       request_state = 0xA5;
  11E2 021A36           LJMP set_interface      ;       set_interface(); return;

L0396:                                          ;   case 0x0A: // GET_INTERFACE
  11E5 7816             MOV R0, #16h
  11E7 745A             MOV A, #5Ah
  11E9 F2               MOVX @R0, A             ;       request_state = 0x5A;
  11EA 121A77           LCALL get_interface     ;       get_interface();
L0336:
  11ED 020EF4           LJMP do_transmit        ;       do_transmit(); return;

L0405:                                          ;   case 0x0C: // SYNCH_FRAME
  11F0 7816             MOV R0, #16h
  11F2 74A5             MOV A, #0A5h
  11F4 F2               MOVX @R0, A             ;       request_state = 0xA5;
  11F5 90FFF6           MOV DPTR, #0FFF6h
  11F8 E4               CLR A
  11F9 F0               MOVX @DPTR, A           ;       TXCNT = 0;
  11FA 785C             MOV R0, #5Ch
  11FC F2               MOVX @R0, A
  11FD 08               INC R0
  11FE F2               MOVX @R0, A             ;       tx_rx_count = 0;
  11FF 22               RET                     ;       return;

L0256:                                          ;   default:
  1200 90FFE1           MOV DPTR, #0FFE1h
  1203 E0               MOVX A, @DPTR
  1204 44C0             ORL A, #0C0h
  1206 F0               MOVX @DPTR, A           ;       EPCON.RXSTL = EPCON.TXSTL = true;
  1207 22               RET                     ;       return;
                                                ;   }
                                                ;}

vendor_request:                                 ;void vendor_request()
  1208 7818             MOV R0, #18h
  120A E2               MOVX A, @R0
  120B 14               DEC A
  120C 6031             JZ L0258                ;   switch (request.bRequest) {
  120E 24FE             ADD A, #0FEh
  1210 601A             JZ L0259
  1212 24FA             ADD A, #0FAh
  1214 6070             JZ L0260
  1216 14               DEC A
  1217 6050             JZ L0261
  1219 14               DEC A
  121A 6059             JZ L0262
  121C 2409             ADD A, #9h
  121E 6003             JZ L0263
  1220 0212AE           LJMP L0264

L0263:                                          ;   case 2: // Get unused variable v39
  1223 7816             MOV R0, #16h
  1225 745A             MOV A, #5Ah
  1227 F2               MOVX @R0, A             ;       request_state = 0x5A;
  1228 7839             MOV R0, #39h
  122A 8007             SJMP L0265              ;       report[0] = v39;
                                                ;       tx_rx_count = 1;
                                                ;       do_transmit(); return;

L0259:                                          ;   case 3: // Get unused variable v3A
  122C 7816             MOV R0, #16h
  122E 745A             MOV A, #5Ah
  1230 F2               MOVX @R0, A             ;       request_state = 0x5A;
  1231 783A             MOV R0, #3Ah
L0265:
  1233 E6               MOV A, @R0
  1234 7817             MOV R0, #17h
  1236 F2               MOVX @R0, A             ;       report[0] = v3A;
  1237 785C             MOV R0, #5Ch
  1239 E4               CLR A
  123A F2               MOVX @R0, A
  123B 08               INC R0
  123C 04               INC A
  123D 8026             SJMP L0266              ;       tx_rx_count = 1;
                                                ;       do_transmit(); return;

L0258:                                          ;   case 1: // Get macros
  123F 7816             MOV R0, #16h
  1241 7422             MOV A, #22h
  1243 F2               MOVX @R0, A             ;       request_state = 0x22;
                                                ;       // The following looks like a convoluted way to assign X5C = X1E and X5D = X1D
                                                ;       tx_rx_count = request.wLength;
  1244 781E             MOV R0, #1Eh            ;       //      R0 = 0x1E;
  1246 E2               MOVX A, @R0             ;       //      A = X1E;
  1247 FF               MOV R7, A               ;       //      R7 = X1E;
  1248 785C             MOV R0, #5Ch            ;       //      R0 = 0x5C;
  124A E4               CLR A                   ;       //      A = 0;
  124B F2               MOVX @R0, A             ;       //X5C = 0;
  124C 08               INC R0                  ;       //      R0 = 0x5D;
  124D EF               MOV A, R7               ;       //      A = X1E;
  124E F2               MOVX @R0, A             ;       //X5D = X1E;
  124F 795D             MOV R1, #5Dh            ;       //      R1 = 0x5D;
  1251 E3               MOVX A, @R1             ;       //      A = X1E;
  1252 F8               MOV R0, A               ;       //      R0 = X1E;
  1253 E4               CLR A                   ;       //      A = 0;
  1254 F3               MOVX @R1, A             ;       //X5D = 0;
  1255 E8               MOV A, R0               ;       //      A = X1E;
  1256 19               DEC R1                  ;       //      R1 = 0x5C;
  1257 F3               MOVX @R1, A             ;       //X5C = X1E;
  1258 781D             MOV R0, #1Dh            ;       //      R0 = 0x1D;
  125A E2               MOVX A, @R0             ;       //      A = X1D;
  125B FF               MOV R7, A               ;       //      R7 = X1D;
  125C 785D             MOV R0, #5Dh            ;       //      R0 = 0x5D;
  125E E2               MOVX A, @R0             ;       //      A = X5D = 0;
  125F 2F               ADD A, R7               ;       //      A = X5D + X1D = X1D, no carry possible;
  1260 F2               MOVX @R0, A             ;       //X5D = X1D;
  1261 18               DEC R0                  ;       //      R0 = 0x5C;
  1262 E2               MOVX A, @R0             ;       //      A = X5C = X1E;
  1263 3400             ADDC A, #0h             ;       //      A = X1E + (carry ? 1 : 0) = X1E;
L0266:
  1265 F2               MOVX @R0, A             ;       //X5C = X1E;
  1266 020EF4           LJMP do_transmit        ;       do_transmit(); return;

L0261:                                          ;   case 0x0A: // Set unused variable v39
  1269 7816             MOV R0, #16h
  126B 74A5             MOV A, #0A5h
  126D F2               MOVX @R0, A             ;       request_state = 0xA5;
  126E 781A             MOV R0, #1Ah
  1270 E2               MOVX A, @R0
  1271 7839             MOV R0, #39h
  1273 800A             SJMP L0297              ;       v39 = HIBYTE(request.wValue);
                                                ;       TXCNT = 0;
                                                ;       return;

L0262:                                          ;   case 0x0B: // Set unused variable v3A
  1275 7816             MOV R0, #16h
  1277 74A5             MOV A, #0A5h
  1279 F2               MOVX @R0, A             ;       request_state = 0xA5;
  127A 7819             MOV R0, #19h
  127C E2               MOVX A, @R0
  127D 783A             MOV R0, #3Ah
L0297:
  127F F6               MOV @R0, A              ;       v3A = LOBYTE(request.wValue);
  1280 90FFF6           MOV DPTR, #0FFF6h
  1283 E4               CLR A
  1284 F0               MOVX @DPTR, A           ;       TXCNT = 0;
  1285 22               RET                     ;       return;

L0260:                                          ;   case 9: // Set macros
  1286 7816             MOV R0, #16h
  1288 7433             MOV A, #33h
  128A F2               MOVX @R0, A             ;       request_state = 0x33;
                                                ;       tx_rx_count = request.wLength;
  128B 781E             MOV R0, #1Eh            ;       //      R0 = 0x1E;
  128D E2               MOVX A, @R0             ;       //      A = X1E;
  128E FF               MOV R7, A               ;       //      R7 = X1E;
  128F 785C             MOV R0, #5Ch            ;       //      R0 = 0x5C;
  1291 E4               CLR A                   ;       //      A = 0;
  1292 F2               MOVX @R0, A             ;       //X5C = 0;
  1293 08               INC R0                  ;       //      R0 = 0x5D;
  1294 EF               MOV A, R7               ;       //      A = X1E;
  1295 F2               MOVX @R0, A             ;       //X5D = X1E;
  1296 795D             MOV R1, #5Dh            ;       //      R1 = 0x5D;
  1298 E3               MOVX A, @R1             ;       //      A = X5D = X1E;
  1299 F8               MOV R0, A               ;       //      R0 = X1E;
  129A E4               CLR A                   ;       //      A = 0;
  129B F3               MOVX @R1, A             ;       //X5D = 0;
  129C E8               MOV A, R0               ;       //      A = X1E;
  129D 19               DEC R1                  ;       //      R1 = 0x5C;
  129E F3               MOVX @R1, A             ;       //X5C = X1E;
  129F 781D             MOV R0, #1Dh            ;       //      R0 = 0x1D;
  12A1 E2               MOVX A, @R0             ;       //      A = X1D;
  12A2 FF               MOV R7, A               ;       //      R7 = X1D;
  12A3 785D             MOV R0, #5Dh            ;       //      R0 = 0x5D;
  12A5 E2               MOVX A, @R0             ;       //      A = X5D = 0;
  12A6 2F               ADD A, R7               ;       //      A = X1D; no carry
  12A7 F2               MOVX @R0, A             ;       //X5D = X1D;
  12A8 18               DEC R0                  ;       //      R0 = 0x5C;
  12A9 E2               MOVX A, @R0             ;       //      A = X5C = X1E;
  12AA 3400             ADDC A, #0h             ;       //      A = X1E + no carry;
  12AC F2               MOVX @R0, A             ;       //X5C = X1E;
  12AD 22               RET                     ;       return;

L0264:                                          ;   default:
  12AE 90FFE1           MOV DPTR, #0FFE1h
  12B1 E0               MOVX A, @DPTR
  12B2 44C0             ORL A, #0C0h
  12B4 F0               MOVX @DPTR, A           ;       EPCON.RXSTL = EPCON.TXSTL = true;
  12B5 22               RET                     ;   }
                                                ;}

isp_read_block:                                 ;void isp_read_block() {
  12B6 780A             MOV R0, #0Ah
  12B8 E2               MOVX A, @R0
  12B9 249A             ADD A, #9Ah             ;   switch (isp_state) {
  12BB 601B             JZ L0284
  12BD 2411             ADD A, #11h
  12BF 6003             JZ L0285
  12C1 02135A           LJMP L0286

L0285:                                          ;   case 0x55:
  12C4 7817             MOV R0, #17h
  12C6 7455             MOV A, #55h
  12C8 F2               MOVX @R0, A             ;       report[0] = 0x55;
  12C9 08               INC R0
  12CA 74AA             MOV A, #0AAh
  12CC F2               MOVX @R0, A             ;       report[1] = 0xAA;
  12CD E4               CLR A
  12CE 08               INC R0
  12CF F2               MOVX @R0, A             ;       report[2] = 0;
  12D0 08               INC R0
  12D1 7428             MOV A, #28h
  12D3 F2               MOVX @R0, A             ;       report[3] = 0x28;
  12D4 E4               CLR A
  12D5 021357           LJMP L0287              ;       isp_state = 0; return;

L0284:                                          ;   case 0x66:
  12D8 E4               CLR A
  12D9 7813             MOV R0, #13h
  12DB F2               MOVX @R0, A
L0290:                                          ;       for (byte __volatile(X13) i = 0; i < 0x40; ++i) {
  12DC E4               CLR A
  12DD FD               MOV R5, A
  12DE 7F01             MOV R7, #1h
  12E0 1219A3           LCALL isp
  12E3 7813             MOV R0, #13h
  12E5 E2               MOVX A, @R0
  12E6 2417             ADD A, #17h
  12E8 F8               MOV R0, A
  12E9 EF               MOV A, R7
  12EA F2               MOVX @R0, A             ;           X17[i] = isp(IspModeRead);
  12EB 780B             MOV R0, #0Bh
  12ED E2               MOVX A, @R0
  12EE FC               MOV R4, A
  12EF 08               INC R0
  12F0 E2               MOVX A, @R0
  12F1 FD               MOV R5, A
  12F2 08               INC R0
  12F3 E2               MOVX A, @R0
  12F4 FE               MOV R6, A
  12F5 08               INC R0
  12F6 E2               MOVX A, @R0
  12F7 2401             ADD A, #1h
  12F9 FF               MOV R7, A
  12FA E4               CLR A
  12FB 3E               ADDC A, R6
  12FC FE               MOV R6, A
  12FD E4               CLR A
  12FE 3D               ADDC A, R5
  12FF FD               MOV R5, A
  1300 E4               CLR A
  1301 3C               ADDC A, R4
  1302 FC               MOV R4, A
  1303 780B             MOV R0, #0Bh
  1305 121037           LCALL dword_write       ;           ++isp_ptr; // dword_write(&isp_ptr, isp_ptr + 1);
  1308 7813             MOV R0, #13h
  130A E2               MOVX A, @R0
  130B 04               INC A
  130C F2               MOVX @R0, A
  130D E2               MOVX A, @R0
  130E C3               CLR C
  130F 9440             SUBB A, #40h
  1311 40C9             JC L0290                ;       }
  1313 780F             MOV R0, #0Fh
  1315 E2               MOVX A, @R0
  1316 FC               MOV R4, A
  1317 08               INC R0
  1318 E2               MOVX A, @R0
  1319 FD               MOV R5, A
  131A 08               INC R0
  131B E2               MOVX A, @R0
  131C FE               MOV R6, A
  131D 08               INC R0
  131E E2               MOVX A, @R0
  131F FF               MOV R7, A
  1320 EF               MOV A, R7
  1321 C0E0             PUSH ACC
  1323 08               INC R0
  1324 E2               MOVX A, @R0
  1325 FB               MOV R3, A
  1326 D0E0             POP ACC
  1328 FF               MOV R7, A
  1329 C3               CLR C
  132A EF               MOV A, R7
  132B 9B               SUBB A, R3
  132C FF               MOV R7, A
  132D EE               MOV A, R6
  132E 9400             SUBB A, #0h
  1330 FE               MOV R6, A
  1331 ED               MOV A, R5
  1332 9400             SUBB A, #0h
  1334 FD               MOV R5, A
  1335 EC               MOV A, R4
  1336 9400             SUBB A, #0h
  1338 FC               MOV R4, A
  1339 780F             MOV R0, #0Fh
  133B 121037           LCALL dword_write       ;       isp_count -= i; // dword_write(&isp_count, isp_count - i);
  133E E4               CLR A
  133F FF               MOV R7, A
  1340 FE               MOV R6, A
  1341 FD               MOV R5, A
  1342 FC               MOV R4, A
  1343 780F             MOV R0, #0Fh
  1345 E2               MOVX A, @R0
  1346 FB               MOV R3, A
  1347 08               INC R0
  1348 E2               MOVX A, @R0
  1349 F9               MOV R1, A
  134A 08               INC R0
  134B E2               MOVX A, @R0
  134C FA               MOV R2, A
  134D 08               INC R0
  134E E2               MOVX A, @R0
  134F CB               XCH A, R3
  1350 F8               MOV R0, A
  1351 C3               CLR C
  1352 121026           LCALL dword_compare
  1355 7003             JNZ L0286               ;       if (isp_count == 0) // dword_compare(isp_count, 0, false)
L0287:
  1357 780A             MOV R0, #0Ah
  1359 F2               MOVX @R0, A             ;            isp_state = 0;
L0286:                                          ;   }
  135A 22               RET                     ;}

; Transmitted in get_descriptor() case 1 -- device descriptor
                                                ;struct DeviceDescriptor device_descriptor = {
  135B 12               DB 012h                 ;   byte bLength = 18;
  135C 01               DB 001h                 ;   byte bDescriptorType = DEVICE;
  135D 11               DB 011h
  135E 01               DB 001h                 ;   word bcdUSB = 0x0111, 1.11;
  135F 00               DB 000h                 ;   byte bDeviceClass = 0;
  1360 00               DB 000h                 ;   byte bDeviceSubClass = 0;
  1361 00               DB 000h                 ;   byte bDeviceProtocol = 0;
  1362 40               DB 040h                 ;   byte bMaxPacketSize0 = 64;
  1363 6A               DB 06Ah
  1364 0E               DB 00Eh                 ;   word idVendor = 0x0E6A;
  1365 0C               DB 00Ch
  1366 03               DB 003h                 ;   word idProduct = 0x030C;
  1367 30               DB 030h
  1368 01               DB 001h                 ;   word bcdDevice = 0x0130, 1.30
  1369 01               DB 001h                 ;   byte iManufacturer = 1;
  136A 02               DB 002h                 ;   byte iProduct = 2;
  136B 00               DB 000h                 ;   byte iSerialNumber = 0; // No string
  136C 01               DB 001h                 ;   byte bNumConfigurations = 1;
                                                ;};

                                                ;struct StringLanguages string_languages = {
  136D 04               DB 004h                 ;   byte bLength = 4;
  136E 03               DB 003h                 ;   byte bDescriptorType = STRING;
  136F 09               DB 009h
  1370 04               DB 004h                 ;   word wLANGID[] = { 0x0409 English (US) };
                                                ;};
                                                ;struct StringDescriptor manufacturer_name = {
  1371 26               DB 026h                 ;   byte bLength = 38;
  1372 03               DB 003h                 ;   byte bDescriptorType = STRING;
                                                ;   u16char_t string[] = {
  1373 54               DB 054h
  1374 00               DB 000h                 ;       'T',
  1375 72               DB 072h
  1376 00               DB 000h                 ;       'r',
  1377 75               DB 075h
  1378 00               DB 000h                 ;       'u',
  1379 6C               DB 06Ch
  137A 00               DB 000h                 ;       'l',
  137B 79               DB 079h
  137C 00               DB 000h                 ;       'y',
  137D 45               DB 045h
  137E 00               DB 000h                 ;       'E',
  137F 72               DB 072h
  1380 00               DB 000h                 ;       'r',
  1381 67               DB 067h
  1382 00               DB 000h                 ;       'g',
  1383 6F               DB 06Fh
  1384 00               DB 000h                 ;       'o',
  1385 6E               DB 06Eh
  1386 00               DB 000h                 ;       'n',
  1387 6F               DB 06Fh
  1388 00               DB 000h                 ;       'o',
  1389 6D               DB 06Dh
  138A 00               DB 000h                 ;       'm',
  138B 69               DB 069h
  138C 00               DB 000h                 ;       'i',
  138D 63               DB 063h
  138E 00               DB 000h                 ;       'c',
  138F 2E               DB 02Eh
  1390 00               DB 000h                 ;       '.',
  1391 63               DB 063h
  1392 00               DB 000h                 ;       'c',
  1393 6F               DB 06Fh
  1394 00               DB 000h                 ;       'o',
  1395 6D               DB 06Dh
  1396 00               DB 000h                 ;       'm'
                                                ;}  };

                                                ;struct StringDescriptor product_name = {
  1397 44               DB 044h                 ;   byte bLength = 68;
  1398 03               DB 003h                 ;   byte bDescriptorType = STRING;
                                                ;   u16char_t string[] = {
  1399 54               DB 054h
  139A 00               DB 000h                 ;       'T',
  139B 72               DB 072h
  139C 00               DB 000h                 ;       'r',
  139D 75               DB 075h
  139E 00               DB 000h                 ;       'u',
  139F 6C               DB 06Ch
  13A0 00               DB 000h                 ;       'l',
  13A1 79               DB 079h
  13A2 00               DB 000h                 ;       'y',
  13A3 20               DB 020h
  13A4 00               DB 000h                 ;       ' ',
  13A5 45               DB 045h
  13A6 00               DB 000h                 ;       'E',
  13A7 72               DB 072h
  13A8 00               DB 000h                 ;       'r',
  13A9 67               DB 067h
  13AA 00               DB 000h                 ;       'g',
  13AB 6F               DB 06Fh
  13AC 00               DB 000h                 ;       'o',
  13AD 6E               DB 06Eh
  13AE 00               DB 000h                 ;       'n',
  13AF 6F               DB 06Fh
  13B0 00               DB 000h                 ;       'o',
  13B1 6D               DB 06Dh
  13B2 00               DB 000h                 ;       'm',
  13B3 69               DB 069h
  13B4 00               DB 000h                 ;       'i',
  13B5 63               DB 063h
  13B6 00               DB 000h                 ;       'c',
  13B7 20               DB 020h
  13B8 00               DB 000h                 ;       ' ',
  13B9 43               DB 043h
  13BA 00               DB 000h                 ;       'C',
  13BB 6F               DB 06Fh
  13BC 00               DB 000h                 ;       'o',
  13BD 6D               DB 06Dh
  13BE 00               DB 000h                 ;       'm',
  13BF 70               DB 070h
  13C0 00               DB 000h                 ;       'p',
  13C1 75               DB 075h
  13C2 00               DB 000h                 ;       'u',
  13C3 74               DB 074h
  13C4 00               DB 000h                 ;       't',
  13C5 65               DB 065h
  13C6 00               DB 000h                 ;       'e',
  13C7 72               DB 072h
  13C8 00               DB 000h                 ;       'r',
  13C9 20               DB 020h
  13CA 00               DB 000h                 ;       ' ',
  13CB 4B               DB 04Bh
  13CC 00               DB 000h                 ;       'K',
  13CD 65               DB 065h
  13CE 00               DB 000h                 ;       'e',
  13CF 79               DB 079h
  13D0 00               DB 000h                 ;       'y',
  13D1 62               DB 062h
  13D2 00               DB 000h                 ;       'b',
  13D3 6F               DB 06Fh
  13D4 00               DB 000h                 ;       'o',
  13D5 61               DB 061h
  13D6 00               DB 000h                 ;       'a',
  13D7 72               DB 072h
  13D8 00               DB 000h                 ;       'r',
  13D9 64               DB 064h
  13DA 00               DB 000h                 ;       'd'
                                                ;}  };

                                                ;struct StringDescriptor serial_number = {
  13DB 0E               DB 00Eh                 ;   byte bLength = 14;
  13DC 03               DB 003h                 ;   byte bDescriptorType = STRING;
                                                ;   u16char_t string[] = {
  13DD 36               DB 036h
  13DE 00               DB 000h                 ;       '6',
  13DF 32               DB 032h
  13E0 00               DB 000h                 ;       '2',
  13E1 31               DB 031h
  13E2 00               DB 000h                 ;       '1',
  13E3 30               DB 030h
  13E4 00               DB 000h                 ;       '0',
  13E5 33               DB 033h
  13E6 00               DB 000h                 ;       '3',
  13E7 31               DB 031h
  13E8 00               DB 000h                 ;       '1'
                                                ;}    };
store_key:                                      ;void store_key() {
  13E9 783C             MOV R0, #3Ch
  13EB E6               MOV A, @R0
  13EC FF               MOV R7, A
  13ED 54F8             ANL A, #0F8h
  13EF 64E0             XRL A, #0E0h
  13F1 7012             JNZ L9602               ;   switch (keycode) {
                                                ;   case 0xE0: case 0xE1: case 0xE2: case 0xE3:
                                                ;   case 0xE4: case 0xE5: case 0xE6: case 0xE7: // Modifiers
  13F3 7E01             MOV R6, #1h
  13F5 EF               MOV A, R7
  13F6 2420             ADD A, #20h
  13F8 6005             JZ L9600
  13FA CE               XCH A, R6
L9601:
  13FB 23               RL A
  13FC DEFD             DJNZ R6, L9601
  13FE CE               XCH A, R6
L9600:
  13FF 784B             MOV R0, #4Bh
  1401 E6               MOV A, @R0
  1402 4E               ORL A, R6
  1403 F6               MOV @R0, A              ;       key_modifiers |= 1 << (keycode - 0xE0);
  1404 22               RET                     ;       return;
L9602:
  1405 EF               MOV A, R7
  1406 C3               CLR C
  1407 94E8             SUBB A, #0E8h
  1409 506B             JNC L0170               ;   case 0xE8: case 0xE9: case 0xEA: case 0xEB:
                                                ;   case 0xEC: case 0xED: case 0xEE: case 0xEF:
                                                ;   case 0xF0: case 0xF1: case 0xF2: case 0xF3:
                                                ;   case 0xF4: case 0xF5: case 0xF6: case 0xF7:
                                                ;   case 0xF8: case 0xF9: case 0xFA: case 0xFB:
                                                ;   case 0xFC: case 0xFD: case 0xFE: case 0xFF: // Media keys
                                                ;       return;
  140B EF               MOV A, R7
  140C 94DE             SUBB A, #0DEh           ;       // carry was set
  140E 6066             JZ L0170                ;   case 0xDF: // Fn
  1410 04               INC A
  1411 6063             JZ L0170                ;   case 0xDE: // IntNum
                                                ;       return;
;;; 70 bytes free
  1413 8044             SJMP L0168
CSEG AT 1459h
L0168:                                          ;   default:
  1459 784A             MOV R0, #4Ah
  145B E6               MOV A, @R0
  145C FF               MOV R7, A
  145D B40605           CJNE A, #6h, L0171      ;       if (keydown_index == 6) {
  1460 783D             MOV R0, #3Dh
  1462 7601             MOV @R0, #1h            ;           phantom = true;
  1464 22               RET                     ;       }

L0171:                                          ;       else {
  1465 783C             MOV R0, #3Ch
  1467 E6               MOV A, @R0
  1468 FE               MOV R6, A
  1469 744D             MOV A, #4Dh
  146B 2F               ADD A, R7
  146C F8               MOV R0, A
  146D EE               MOV A, R6
  146E F6               MOV @R0, A
  146F 784A             MOV R0, #4Ah
  1471 06               INC @R0                 ;           keys_down[keydown_index++] = keycode;
  1472 E4               CLR A
  1473 783C             MOV R0, #3Ch
  1475 F6               MOV @R0, A              ;           keycode = 0;
L0170:
  1476 22               RET                     ;}  }   }

numlock_off:                                    ;void numlock_off() {
  1477 7805             MOV R0, #5h
  1479 E2               MOVX A, @R0
  147A 64BB             XRL A, #0BBh
  147C 6003             JZ L0010                ;   if (numlock_state == 0xBB) {
  147E 021501           LJMP L0011

L0010:
  1481 C2AF             CLR EA                  ;       __uninterrupted {
  1483 90FFF1           MOV DPTR, #0FFF1h
  1486 04               INC A
  1487 F0               MOVX @DPTR, A           ;           EPINDEX = 1;
  1488 784B             MOV R0, #4Bh
  148A E6               MOV A, @R0
  148B 90FFF3           MOV DPTR, #0FFF3h
  148E F0               MOVX @DPTR, A           ;           TXDAT = key_modifiers;
  148F E4               CLR A
  1490 F0               MOVX @DPTR, A           ;           TXDAT = 0;
  1491 784D             MOV R0, #4Dh
  1493 E6               MOV A, @R0
  1494 F0               MOVX @DPTR, A           ;           TXDAT = keys_down[0];
  1495 08               INC R0
  1496 E6               MOV A, @R0
  1497 F0               MOVX @DPTR, A           ;           TXDAT = keys_down[1];
  1498 08               INC R0
  1499 E6               MOV A, @R0
  149A F0               MOVX @DPTR, A           ;           TXDAT = keys_down[2];
  149B 08               INC R0
  149C E6               MOV A, @R0
  149D F0               MOVX @DPTR, A           ;           TXDAT = keys_down[3];
  149E 08               INC R0
  149F E6               MOV A, @R0
  14A0 F0               MOVX @DPTR, A           ;           TXDAT = keys_down[4];
  14A1 7453             MOV A, #53h
  14A3 F0               MOVX @DPTR, A           ;           TXDAT = 0x53; // Num
  14A4 7838             MOV R0, #38h
  14A6 7601             MOV @R0, #1h            ;           usb1_transmitting = 1;
  14A8 90FFF6           MOV DPTR, #0FFF6h
  14AB 7408             MOV A, #8h
  14AD F0               MOVX @DPTR, A           ;           TXCNT = 8;
  14AE 90FFF1           MOV DPTR, #0FFF1h
  14B1 E4               CLR A
  14B2 F0               MOVX @DPTR, A           ;           EPINDEX = 0;
  14B3 D2AF             SETB EA                 ;       }
L0012:                                          ;       do {
  14B5 7838             MOV R0, #38h
  14B7 E6               MOV A, @R0
  14B8 6401             XRL A, #1h
  14BA 60F9             JZ L0012                ;       } while (usb1_transmitting == 1);
  14BC 121A94           LCALL micro_delay_1000  ;       micro_delay_1000();
  14BF C2AF             CLR EA                  ;       __uninterrupted {
  14C1 90FFF1           MOV DPTR, #0FFF1h
  14C4 7401             MOV A, #1h
  14C6 F0               MOVX @DPTR, A           ;           EPINDEX = 1;
  14C7 784B             MOV R0, #4Bh
  14C9 E6               MOV A, @R0
  14CA 90FFF3           MOV DPTR, #0FFF3h
  14CD F0               MOVX @DPTR, A           ;           TXDAT = key_modifiers;
  14CE E4               CLR A
  14CF F0               MOVX @DPTR, A           ;           TXDAT = 0;
  14D0 784D             MOV R0, #4Dh
  14D2 E6               MOV A, @R0
  14D3 F0               MOVX @DPTR, A           ;           TXDAT = keys_down[0];
  14D4 08               INC R0
  14D5 E6               MOV A, @R0
  14D6 F0               MOVX @DPTR, A           ;           TXDAT = keys_down[1];
  14D7 08               INC R0
  14D8 E6               MOV A, @R0
  14D9 F0               MOVX @DPTR, A           ;           TXDAT = keys_down[2];
  14DA 08               INC R0
  14DB E6               MOV A, @R0
  14DC F0               MOVX @DPTR, A           ;           TXDAT = keys_down[3];
  14DD 08               INC R0
  14DE E6               MOV A, @R0
  14DF F0               MOVX @DPTR, A           ;           TXDAT = keys_down[4];
  14E0 E4               CLR A
  14E1 F0               MOVX @DPTR, A           ;           TXDAT = 0;
  14E2 7838             MOV R0, #38h
  14E4 7601             MOV @R0, #1h            ;           usb1_transmitting = 1;
  14E6 90FFF6           MOV DPTR, #0FFF6h
  14E9 7408             MOV A, #8h
  14EB F0               MOVX @DPTR, A           ;           TXCNT = 8;
  14EC 90FFF1           MOV DPTR, #0FFF1h
  14EF E4               CLR A
  14F0 F0               MOVX @DPTR, A           ;           EPINDEX = 0;
  14F1 D2AF             SETB EA                 ;       }
L0014:                                          ;       do {
  14F3 7838             MOV R0, #38h
  14F5 E6               MOV A, @R0
  14F6 6401             XRL A, #1h
  14F8 60F9             JZ L0014                ;       } while (usb1_transmitting == 1);
  14FA E4               CLR A
  14FB 7805             MOV R0, #5h
  14FD F2               MOVX @R0, A             ;       numlock_state = 0;
  14FE 121A9E           LCALL micro_delay_500   ;       micro_delay_500();
L0011:                                          ;   }
  1501 22               RET                     ;}

numlock_on:                                     ;void numlock_on() {
  1502 7805             MOV R0, #5h
  1504 E2               MOVX A, @R0
  1505 64EA             XRL A, #0EAh
  1507 7071             JNZ L0123               ;   if (numlock_state == 0xEA
  1509 00               NOP
  150A 00               NOP
  150B 00               NOP
  150C 20006B           JB 0h, L0123            ;       and not led_state.1)    // OS NumLock if OFF
                                                ;   {
  150F C2AF             CLR EA                  ;       __uninterrupted {       // Send NumLock keypress
  1511 90FFF1           MOV DPTR, #0FFF1h
  1514 04               INC A
  1515 F0               MOVX @DPTR, A           ;           EPINDEX = 1;
  1516 784B             MOV R0, #4Bh
  1518 E6               MOV A, @R0
  1519 90FFF3           MOV DPTR, #0FFF3h
  151C F0               MOVX @DPTR, A           ;           TXDAT = key_modifiers;
  151D E4               CLR A
  151E F0               MOVX @DPTR, A           ;           TXDAT = 0;
  151F 7453             MOV A, #53h
  1521 F0               MOVX @DPTR, A           ;           TXDAT = 0x53; // NumLock
  1522 E4               CLR A
  1523 F0               MOVX @DPTR, A           ;           TXDAT = 0;
  1524 F0               MOVX @DPTR, A           ;           TXDAT = 0;
  1525 F0               MOVX @DPTR, A           ;           TXDAT = 0;
  1526 F0               MOVX @DPTR, A           ;           TXDAT = 0;
  1527 F0               MOVX @DPTR, A           ;           TXDAT = 0;
  1528 7838             MOV R0, #38h
  152A 7601             MOV @R0, #1h            ;           usb1_transmitting = 1;
  152C 90FFF6           MOV DPTR, #0FFF6h
  152F 7408             MOV A, #8h
  1531 F0               MOVX @DPTR, A           ;           TXCNT = 8;
  1532 90FFF1           MOV DPTR, #0FFF1h
  1535 E4               CLR A
  1536 F0               MOVX @DPTR, A           ;           EPINDEX = 0;
  1537 D2AF             SETB EA                 ;       }
L0124:                                          ;       do {
  1539 7838             MOV R0, #38h
  153B E6               MOV A, @R0
  153C 6401             XRL A, #1h
  153E 60F9             JZ L0124                ;       } while (usb1_transmitting == 1);
  1540 121A94           LCALL micro_delay_1000  ;       micro_delay_1000();
  1543 C2AF             CLR EA                  ;       __uninterrupted {
  1545 90FFF1           MOV DPTR, #0FFF1h
  1548 7401             MOV A, #1h
  154A F0               MOVX @DPTR, A           ;           EPINDEX = 1;
  154B 784B             MOV R0, #4Bh
  154D E6               MOV A, @R0
  154E 90FFF3           MOV DPTR, #0FFF3h
  1551 F0               MOVX @DPTR, A           ;           TXDAT = key_modifiers;
  1552 E4               CLR A
  1553 F0               MOVX @DPTR, A           ;           TXDAT = 0;
  1554 F0               MOVX @DPTR, A           ;           TXDAT = 0;
  1555 F0               MOVX @DPTR, A           ;           TXDAT = 0;
  1556 F0               MOVX @DPTR, A           ;           TXDAT = 0;
  1557 F0               MOVX @DPTR, A           ;           TXDAT = 0;
  1558 F0               MOVX @DPTR, A           ;           TXDAT = 0;
  1559 F0               MOVX @DPTR, A           ;           TXDAT = 0;
  155A 7838             MOV R0, #38h
  155C 7601             MOV @R0, #1h            ;           usb1_transmitting = 1;
  155E 90FFF6           MOV DPTR, #0FFF6h
  1561 7408             MOV A, #8h
  1563 F0               MOVX @DPTR, A           ;           TXCNT = 8;
  1564 90FFF1           MOV DPTR, #0FFF1h
  1567 E4               CLR A
  1568 F0               MOVX @DPTR, A           ;           EPINDEX = 0;
  1569 D2AF             SETB EA                 ;       }
L0125:                                          ;       do {
  156B 7838             MOV R0, #38h
  156D E6               MOV A, @R0
  156E 6401             XRL A, #1h
  1570 60F9             JZ L0125                ;       } while (usb1_transmitting == 1);
  1572 121A9E           LCALL micro_delay_500   ;       micro_delay_500();
  1575 7805             MOV R0, #5h
  1577 74CC             MOV A, #0CCh
  1579 F2               MOVX @R0, A             ;       numlock_state = 0xCC;
L0123:                                          ;   }
  157A 22               RET                     ;}

scan_column:                                    ;void scan_column() {
  157B 7823             MOV R0, #23h
  157D E6               MOV A, @R0
  157E B41202           CJNE A, #12h, L0149     ;   if (column_index == sizeof(key_matrix))
  1581 E4               CLR A
  1582 F6               MOV @R0, A              ;       column_index = 0; // scan 18 columns over and over?
L0149:
  1583 7823             MOV R0, #23h
  1585 E6               MOV A, @R0
  1586 FF               MOV R7, A
  1587 12169B           LCALL read_column       ;   byte __register(R7) raw_value = read_column(column_index);

  158A E523             MOV A, 23h             ;        R6 = column_index
  158C FE               MOV R6, A
  158D 2426             ADD A, #26h
  158F F8               MOV R0, A               ;       R0 = &key_matrix[column_index]
  1590 E6               MOV A, @R0
  1591 FD               MOV R5, A               ;       R5 = key_matrix[column_index]
  1592 6F               XRL A, R7
  1593 FF               MOV R7, A               ;   byte __register(R7) delta = raw_value ^ key_matrix[column_index];
  1594 EE               MOV A, R6
  1595 24BC             ADD A, #0BCh
  1597 F8               MOV R0, A               ;       R0 = &clockA[column_index]
  1598 2412             ADD A, #12h
  159A F9               MOV R1, A               ;       R1 = &clockB[column_index]
  159B E6               MOV A, @R0
  159C 67               XRL A, @R1              ;   clockA[column_index] ^= clockB[column_index];
  159D 5F               ANL A, R7
  159E F6               MOV @R0, A              ;   clockA[column_index] &= delta;
  159F E7               MOV A, @R1
  15A0 F4               CPL A                   ;   clockB[column_index] = ~clockB[column_index];
  15A1 5F               ANL A, R7
  15A2 F7               MOV @R1, A              ;   clockB[column_index] &= delta;
  15A3 EF               MOV A, R7
  15A4 F4               CPL A
  15A5 46               ORL A, @R0
  15A6 47               ORL A, @R1
  15A7 F4               CPL A                   ;   byte __register(A) changes = ~(~delta | clockA[column_index] | clockB[column_index]);
  15A8 6D               XRL A, R5
  15A9 7824             MOV R0, #24h
  15AB F6               MOV @R0, A              ;   column_value = key_matrix[column_index] ^ changes;
  15AC 00               NOP
  15AD E4               CLR A
  15AE 783D             MOV R0, #3Dh
  15B0 F6               MOV @R0, A              ;   phantom = false;
  15B1 7824             MOV R0, #24h
  15B3 E6               MOV A, @R0
  15B4 6007             JZ L0151                ;   if (column_value) {
  15B6 121B12           LCALL L0152             ;
  15B9 783D             MOV R0, #3Dh
  15BB EF               MOV A, R7
  15BC F6               MOV @R0, A              ;       phantom = f0152(); // always 0 :/
L0151:                                          ;   }
  15BD 783D             MOV R0, #3Dh
  15BF E6               MOV A, @R0
  15C0 701B             JNZ L0153               ;   if (not phantom) { // always
  15C2 7823             MOV R0, #23h
  15C4 E6               MOV A, @R0
  15C5 2426             ADD A, #26h
  15C7 F8               MOV R0, A
  15C8 E6               MOV A, @R0
  15C9 7825             MOV R0, #25h
  15CB F6               MOV @R0, A              ;       old_column_value = key_matrix[column_index];
  15CC 120C61           LCALL decode_fn         ;       decode_fn();
  15CF 7824             MOV R0, #24h
  15D1 E6               MOV A, @R0
  15D2 FF               MOV R7, A
  15D3 18               DEC R0
  15D4 E6               MOV A, @R0
  15D5 2426             ADD A, #26h
  15D7 F8               MOV R0, A
  15D8 EF               MOV A, R7
  15D9 F6               MOV @R0, A              ;       key_matrix[column_index] = column_value;
  15DA 12084B           LCALL decode_numlock    ;       decode_numlock();
L0153:                                          ;   }
  15DD 12089A           LCALL scan_delay        ;   scan_delay();
  15E0 7823             MOV R0, #23h
  15E2 06               INC @R0                 ;   ++column_index;
  15E3 22               RET                     ;}

init_interrupts:                                ;void init_interrupts() {
  15E4 E4               CLR A
  15E5 F5A8             MOV IE, A               ;   IE = 0;
  15E7 75ADA0           MOV 0ADh, #0A0h         ;   AUXIE = EUSB | EKB;
  15EA 75AE20           MOV 0AEh, #20h          ;   AUXIP = PKBI; // Keypad interrupt
  15ED F5D0             MOV PSW, A              ;   PSW = 0;
  15EF 75B812           MOV IP, #12h            ;   IP = PS | PT0; // Serial port | Timer 0
  15F2 758921           MOV TMOD, #21h          ;   TMOD = M1 << 4 | M0; // Timer 1: 8-bit auto reload; timer 0: 16-bit
  15F5 C28C             CLR TR0                 ;   TR0 = false;
  15F7 D2A9             SETB ET0                ;   ET0 = true;
  15F9 7801             MOV R0, #1h
  15FB E5E1             MOV A, 0E1h
  15FD F2               MOVX @R0, A             ;   wdtcr = WDTCR;
  15FE E2               MOVX A, @R0
  15FF 4437             ORL A, #37h
  1601 F2               MOVX @R0, A             ;   wdtcr |= ENW | CLRW | PS2 | PS1 | PS0; // enable, clear, prescale 1/256
                                                ;     // 32768 * 12 * 256 / 12MHz = 8.39 s
  1602 75C758           MOV 0C7h, #58h          ;   CKCON = XCKS3 | XCKS1 | XCKS0; // 12MHz
  1605 43BF04           ORL 0BFh, #4h           ;   CKCON2.EN_PLL = true;
L0226:                                          ;   do {
  1608 E5BF             MOV A, 0BFh
  160A 30E1FB           JNB ACC.1, L0226        ;   } while (not CKCON2.PLL_RDY);
  160D D2AF             SETB EA                 ;   EA = true; // enable interrupts
  160F 43BF08           ORL 0BFh, #8h           ;   CKCON2.EN_USB = true;
  1612 7F01             MOV R7, #1h
  1614 121ADC           LCALL delay             ;   delay(1);
L0228:                                          ;   do {
  1617 90FFCC           MOV DPTR, #0FFCCh
  161A E0               MOVX A, @DPTR
  161B 4401             ORL A, #1h
  161D F0               MOVX @DPTR, A           ;       USB_CC.0 = true;
  161E E0               MOVX A, @DPTR
  161F 30E0F5           JNB ACC.0, L0228        ;   } while (not USB_CC.0);
  1622 7F04             MOV R7, #4h
  1624 121ADC           LCALL delay             ;   delay(4);
L0229:                                          ;   do {
  1627 90FFCC           MOV DPTR, #0FFCCh
  162A E0               MOVX A, @DPTR
  162B 4402             ORL A, #2h
  162D F0               MOVX @DPTR, A           ;       USB_CC.1 = true;
  162E E0               MOVX A, @DPTR
  162F 30E1F5           JNB ACC.1, L0229        ;   } while (not USB_CC.1);
  1632 43BF20           ORL 0BFh, #20h          ;   CKCON2.OSCDR0 = true;
  1635 7591FF           MOV 91h, #0FFh          ;   P1M0 = 0xFF;
  1638 7592FF           MOV 92h, #0FFh          ;   P1M1 = 0xFF;
  163B 7595FF           MOV 95h, #0FFh          ;   P2M0 = 0xFF;
  163E 7596FF           MOV 96h, #0FFh          ;   P2M1 = 0xFF;
  1641 75B118           MOV 0B1h, #18h          ;   P3M0 = 0xFF;
  1644 75B218           MOV 0B2h, #18h          ;   P3M1 = 0xFF;
  1647 7FFF             MOV R7, #0FFh
  1649 021ADC           LJMP delay              ;   delay(255);
                                                ;}

do_keypad:                                      ;void __interrupt keypad() {
  164C C0E0             PUSH ACC
  164E C083             PUSH DPH
  1650 C082             PUSH DPL
  1652 C0D0             PUSH PSW
  1654 75D010           MOV PSW, #10h           ;   // use register bank 2
  1657 7801             MOV R0, #1h
  1659 E2               MOVX A, @R0
  165A F5E1             MOV 0E1h, A             ;   WDTCR = wdtcr; // Watch-dog Timer
  165C 75D5FF           MOV 0D5h, #0FFh         ;   KBPATN = 0xFF;
  165F 75D600           MOV 0D6h, #0h           ;   KBCON = 0;
  1662 75D700           MOV 0D7h, #0h           ;   KBMASK = 0;
L0234:                                          ;   do {
  1665 E5BF             MOV A, 0BFh
  1667 30E1FB           JNB ACC.1, L0234        ;   } while (not CKCON2.PLL_RDY);
  166A 7814             MOV R0, #14h
  166C E2               MOVX A, @R0
  166D 6007             JZ L0235                ;   if (remote_wakeup != 0) {
  166F 90FFC9           MOV DPTR, #0FFC9h
  1672 E0               MOVX A, @DPTR
  1673 4420             ORL A, #20h
  1675 F0               MOVX @DPTR, A           ;       UPCON.URWU = true; // 0x20 USB Remote Wake-Up Trigger
L0235:                                          ;   }
  1676 7F04             MOV R7, #4h
  1678 121ADC           LCALL delay             ;   delay(4);
L0236:                                          ;   do {
  167B 90FFCC           MOV DPTR, #0FFCCh
  167E E0               MOVX A, @DPTR
  167F 4402             ORL A, #2h
  1681 F0               MOVX @DPTR, A           ;       USB_CC.1 = true;
  1682 E0               MOVX A, @DPTR
  1683 30E1F5           JNB ACC.1, L0236        ;   } while (not USB_CC.1);
  1686 7814             MOV R0, #14h
  1688 E2               MOVX A, @R0
  1689 6007             JZ L0237                ;   if (remote_wakeup != 0) {
  168B 90FFC9           MOV DPTR, #0FFC9h
  168E E0               MOVX A, @DPTR
  168F 4420             ORL A, #20h
  1691 F0               MOVX @DPTR, A           ;       UPCON.URWU = true; // 0x20 USB Remote Wake-Up Trigger
L0237:                                          ;   }
  1692 D0D0             POP PSW
  1694 D082             POP DPL
  1696 D083             POP DPH
  1698 D0E0             POP ACC
  169A 32               RETI                    ;} // keypad

read_column:                                    ;byte __register(R7) read_column(byte __register(R7) index) {
  169B EF               MOV A, R7
  169C 75F003           MOV B, #3h
  169F A4               MUL AB
  16A0 247C             ADD A, #7Ch
  16A2 F582             MOV DPL, A
  16A4 E4               CLR A
  16A5 3418             ADDC A, #18h
  16A7 F583             MOV DPH, A
  16A9 E4               CLR A
  16AA 93               MOVC A, @A+DPTR
  16AB F590             MOV P1, A               ;   P1 = matrix_mask[index][0];
  16AD EF               MOV A, R7
  16AE 75F003           MOV B, #3h
  16B1 A4               MUL AB
  16B2 247D             ADD A, #7Dh
  16B4 F582             MOV DPL, A
  16B6 E4               CLR A
  16B7 3418             ADDC A, #18h
  16B9 F583             MOV DPH, A
  16BB E4               CLR A
  16BC 93               MOVC A, @A+DPTR
  16BD F5A0             MOV P2, A               ;   P2 = matrix_mask[index][1];
  16BF EF               MOV A, R7
  16C0 75F003           MOV B, #3h
  16C3 A4               MUL AB
  16C4 247E             ADD A, #7Eh
  16C6 F582             MOV DPL, A
  16C8 E4               CLR A
  16C9 3418             ADDC A, #18h
  16CB F583             MOV DPH, A
  16CD E4               CLR A
  16CE 93               MOVC A, @A+DPTR
  16CF 52B0             ANL P3, A               ;   P3 &= matrix_mask[index][2];
  16D1 7F0A             MOV R7, #0Ah
  16D3 121AA5           LCALL micro_delay       ;   micro_delay(10); // 10
  16D6 7825             MOV R0, #25h
  16D8 A680             MOV @R0, P0
  16DA E6               MOV A, @R0
  16DB F4               CPL A
  16DC F6               MOV @R0, A              ;   new_column_value = ~P0;
  16DD 7590FF           MOV P1, #0FFh           ;   P1 = 0xFF;
  16E0 75A0FF           MOV P2, #0FFh           ;   P2 = 0xFF;
  16E3 43B018           ORL P3, #18h            ;   P3 |= 0x18;
  16E6 E6               MOV A, @R0
  16E7 FF               MOV R7, A               ;   return new_column_value;
  16E8 22               RET                     ;}

set_configuration:                              ;void set_configuration() {
  16E9 7819             MOV R0, #19h
  16EB E2               MOVX A, @R0
  16EC 785E             MOV R0, #5Eh
  16EE F2               MOVX @R0, A             ;   usb_configuration = LOBYTE(request.wValue);
  16EF 602D             JZ L0392                ;   if (LOBYTE(request.wValue) != 0) {
  16F1 7F01             MOV R7, #1h
L0393:                                          ;       for (byte __register(R7) i = 1; i != 6; ++i) {
  16F3 90FFF1           MOV DPTR, #0FFF1h
  16F6 EF               MOV A, R7
  16F7 F0               MOVX @DPTR, A           ;           EPINDEX = i;
  16F8 90FFE1           MOV DPTR, #0FFE1h
  16FB 7405             MOV A, #5h
  16FD F0               MOVX @DPTR, A           ;           EPCON = RXEPEN | TXEPEN;
  16FE 90FFE4           MOV DPTR, #0FFE4h
  1701 7480             MOV A, #80h
  1703 F0               MOVX @DPTR, A           ;           RXCON = RXCLR;
  1704 90FFF4           MOV DPTR, #0FFF4h
  1707 F0               MOVX @DPTR, A           ;           TXCON = TXCLR;
  1708 90FFE2           MOV DPTR, #0FFE2h
  170B 7408             MOV A, #8h
  170D F0               MOVX @DPTR, A           ;           RXSTAT = ISOOVW;
  170E 90FFF2           MOV DPTR, #0FFF2h
  1711 F0               MOVX @DPTR, A           ;           TXSTAT = TXSOVW;
  1712 0F               INC R7
  1713 EF               MOV A, R7
  1714 B406DC           CJNE A, #6h, L0393      ;       }
  1717 7815             MOV R0, #15h
  1719 7401             MOV A, #1h
  171B F2               MOVX @R0, A             ;       configured = true;
  171C 8011             SJMP L0394

L0392:                                          ;   } else
  171E 7F01             MOV R7, #1h
L0395:                                          ;       for (byte __register(R7) i = 1; i != 6; ++i) {
  1720 90FFF1           MOV DPTR, #0FFF1h
  1723 EF               MOV A, R7
  1724 F0               MOVX @DPTR, A           ;           EPINDEX = i;
  1725 90FFE1           MOV DPTR, #0FFE1h
  1728 E4               CLR A
  1729 F0               MOVX @DPTR, A           ;           EPCON = 0;
  172A 0F               INC R7
  172B EF               MOV A, R7
  172C B406F1           CJNE A, #6h, L0395      ;       }
L0394:                                          ;   }
  172F 90FFF1           MOV DPTR, #0FFF1h
  1732 E4               CLR A
  1733 F0               MOVX @DPTR, A           ;   EPINDEX = 0;
  1734 22               RET                     ;}

clear_feature:                                  ;void clear_feature() {
  1735 7817             MOV R0, #17h
  1737 E2               MOVX A, @R0
  1738 5403             ANL A, #3h              ;   switch (request.bmRequestType & 3) // Recipient
  173A 14               DEC A
  173B 6040             JZ L0347
  173D 14               DEC A
  173E 6011             JZ L0348
  1740 2402             ADD A, #2h
  1742 7032             JNZ L0349               ;   case 0: // Device
  1744 7819             MOV R0, #19h
  1746 E2               MOVX A, @R0
  1747 B40105           CJNE A, #1h, L0350      ;       if (LOBYTE(request.wValue) == 1) { // DEVICE_REMOTE_WAKEUP
  174A E4               CLR A
  174B 7814             MOV R0, #14h
  174D F2               MOVX @R0, A             ;            remote_wakeup = 0;
  174E 22               RET

L0350:                                          ;       }
  174F 8025             SJMP L0349              ;       EPCON.RXSTL = EPCON.TXSTL = 1; return;

L0348:                                          ;   case 2: // Endpoint
  1751 7819             MOV R0, #19h
  1753 E2               MOVX A, @R0
  1754 701E             JNZ L0351               ;       if (LOBYTE(request.wValue) == 0) { // ENDPOINT_HALT
  1756 781B             MOV R0, #1Bh
  1758 E2               MOVX A, @R0
  1759 540F             ANL A, #0Fh
  175B 90FFF1           MOV DPTR, #0FFF1h
  175E F0               MOVX @DPTR, A           ;           EPINDEX = LOBYTE(request.wIndex) & 0x0F;
  175F 90FFE1           MOV DPTR, #0FFE1h
  1762 E0               MOVX A, @DPTR
  1763 543F             ANL A, #3Fh
  1765 F0               MOVX @DPTR, A           ;           EPCON.RXSTL = EPCON.TXSTL = 0;
  1766 A3               INC DPTR
  1767 7408             MOV A, #8h
  1769 F0               MOVX @DPTR, A           ;           RXSTAT = ISOOVW;
  176A 90FFF2           MOV DPTR, #0FFF2h
  176D F0               MOVX @DPTR, A           ;           TXSTAT = 0x08;
  176E 90FFF1           MOV DPTR, #0FFF1h
  1771 E4               CLR A
  1772 F0               MOVX @DPTR, A           ;           EPINDEX = 0;
  1773 22               RET                     ;           return;

L0351:                                          ;       }
  1774 8000             SJMP L0349              ;       EPCON.RXSTL = EPCON.TXSTL = 1; return;

L0349:                                          ;   case 3: // Other
  1776 90FFE1           MOV DPTR, #0FFE1h
  1779 E0               MOVX A, @DPTR
  177A 44C0             ORL A, #0C0h
  177C F0               MOVX @DPTR, A           ;       EPCON.RXSTL = EPCON.TXSTL = 1;
L0347:                                          ;   }
  177D 22               RET                     ;}

init_vars:                                      ;void init_vars() {
  177E E4               CLR A
  177F F520             MOV 20h, A              ;   led_state = 0;
  1781 7803             MOV R0, #3h
  1783 F2               MOVX @R0, A             ;   fn_down = 0;
  1784 7807             MOV R0, #7h
  1786 F2               MOVX @R0, A             ;   media_key_down = 0;
  1787 7805             MOV R0, #5h
  1789 F2               MOVX @R0, A             ;   numlock_state = 0;
  178A 18               DEC R0
  178B F2               MOVX @R0, A             ;   numlock_timer = 0;
  178C 7838             MOV R0, #38h
  178E F6               MOV @R0, A              ;   usb1_transmitting = 0;
  178F 7823             MOV R0, #23h
  1791 F6               MOV @R0, A              ;   column_index = 0;
  1792 783E             MOV R0, #3Eh
  1794 F6               MOV @R0, A              ;   normal_key = false;
  1795 18               DEC R0
  1796 F6               MOV @R0, A              ;   phantom = false;
  1797 FE               MOV R6, A
  1798 7F12             MOV R7, #12h
  179A FD               MOV R5, A
  179B FB               MOV R3, A
  179C 7A00             MOV R2, #0h
  179E 7926             MOV R1, #26h
  17A0 12105C           LCALL memset            ;   memset(&key_matrix, sizeof(key_matrix), 0);
  17A3 E4               CLR A
  17A4 784A             MOV R0, #4Ah
  17A6 F6               MOV @R0, A              ;   keydown_index = 0;
  17A7 FE               MOV R6, A
  17A8 7F08             MOV R7, #8h
  17AA FD               MOV R5, A
  17AB FB               MOV R3, A
  17AC 7A00             MOV R2, #0h
  17AE 794B             MOV R1, #4Bh
  17B0 12105C           LCALL memset            ;   memset(&hid_report, 8, 0);
  17B3 7821             MOV R0, #21h
  17B5 765A             MOV @R0, #5Ah           ;   kb_mode = 0x5A;
  17B7 E4               CLR A
  17B8 08               INC R0
  17B9 F6               MOV @R0, A              ;   shift_f12_count = 0;
  17BA 7845             MOV R0, #45h
  17BC F6               MOV @R0, A              ;   usb2_transmitting = 0;
  17BD 7847             MOV R0, #47h
  17BF F6               MOV @R0, A              ;   media_keycode = 0;
  17C0 18               DEC R0
  17C1 F6               MOV @R0, A              ;   media_report_ready = 0;
  17C2 22               RET                     ;}

set_feature:                                    ;void set_feature() {
  17C3 7817             MOV R0, #17h
  17C5 E2               MOVX A, @R0
  17C6 5403             ANL A, #3h              ;   switch (LOBYTE(request.bmRequestType) & 3) { // Recipient
  17C8 14               DEC A
  17C9 6039             JZ L0354                ;       // case 1
  17CB 14               DEC A
  17CC 6012             JZ L0355                ;       // case 2
  17CE 2402             ADD A, #2h
  17D0 702B             JNZ L0356               ;   case 0: // Device
  17D2 7819             MOV R0, #19h
  17D4 E2               MOVX A, @R0
  17D5 B40106           CJNE A, #1h, L0357      ;       if (LOBYTE(request.wValue) == 1) { // DEVICE_REMOTE_WAKEUP
  17D8 7814             MOV R0, #14h
  17DA 7401             MOV A, #1h
  17DC F2               MOVX @R0, A             ;           remote_wakeup = 1;
  17DD 22               RET                     ;           return;

L0357:                                          ;       }
  17DE 801D             SJMP L0356              ;       EPCON.RXSTL = EPCON.TXSTL = 1; return;

L0355:                                          ;   case 2: // Endpoint
  17E0 7819             MOV R0, #19h
  17E2 E2               MOVX A, @R0
  17E3 7016             JNZ L0358               ;       if (LOBYTE(request.wValue) == 0) { // ENDPOINT_HALT
  17E5 781B             MOV R0, #1Bh
  17E7 E2               MOVX A, @R0
  17E8 540F             ANL A, #0Fh
  17EA 90FFF1           MOV DPTR, #0FFF1h
  17ED F0               MOVX @DPTR, A           ;           EPINDEX = LOBYTE(request.wIndex) & 0x0F;
  17EE 90FFE1           MOV DPTR, #0FFE1h
  17F1 E0               MOVX A, @DPTR
  17F2 44C0             ORL A, #0C0h
  17F4 F0               MOVX @DPTR, A           ;           EPCON.RXSTL = EPCON.TXSTL = 1;
  17F5 90FFF1           MOV DPTR, #0FFF1h
  17F8 E4               CLR A
  17F9 F0               MOVX @DPTR, A           ;           EPINDEX = 0;
  17FA 22               RET                     ;           return;

L0358:                                          ;       }
  17FB 8000             SJMP L0356              ;       EPCON.RXSTL = EPCON.TXSTL = 1; return;

L0356:                                          ;   case 3: // Other
  17FD 90FFE1           MOV DPTR, #0FFE1h
  1800 E0               MOVX A, @DPTR
  1801 44C0             ORL A, #0C0h
  1803 F0               MOVX @DPTR, A           ;       EPCON.RXSTL = EPCON.TXSTL = 1;
L0354:                                          ;   }
  1804 22               RET                     ;}

init_hw:                                        ;void init_hw() {
  1805 90FFD9           MOV DPTR, #0FFD9h
  1808 E4               CLR A
  1809 F0               MOVX @DPTR, A           ;       IEN = 0;
  180A 90FFF1           MOV DPTR, #0FFF1h
  180D F0               MOVX @DPTR, A           ;       EPINDEX = 0;
  180E 90FFE1           MOV DPTR, #0FFE1h
  1811 7405             MOV A, #5h
  1813 F0               MOVX @DPTR, A           ;       EPCON = RXEPEN | TXEPEN;
  1814 E0               MOVX A, @DPTR
  1815 44C0             ORL A, #0C0h
  1817 F0               MOVX @DPTR, A           ;       EPCON.RXSTL = EPCON.TXSTL = true;
  1818 90FFF4           MOV DPTR, #0FFF4h
  181B 7480             MOV A, #80h
  181D F0               MOVX @DPTR, A           ;       TXCON = TXCLR;
  181E 90FFE4           MOV DPTR, #0FFE4h
  1821 F0               MOVX @DPTR, A           ;       RXCON = RXCLR;
  1822 90FFDA           MOV DPTR, #0FFDAh
  1825 7497             MOV A, #97h
  1827 F0               MOVX @DPTR, A           ;       UIE = SOFIE | UTXIE2 | UTXIE1 | URXIE0 | UTXIE0;
  1828 90FFD9           MOV DPTR, #0FFD9h
  182B 7406             MOV A, #6h
  182D F0               MOVX @DPTR, A           ;       IEN = EFSR | EF;
  182E 785B             MOV R0, #5Bh
  1830 7440             MOV A, #40h
  1832 F2               MOVX @R0, A             ;       max_transmit = 0x40;
  1833 E4               CLR A
  1834 7815             MOV R0, #15h
  1836 F2               MOVX @R0, A             ;       configured = false;
  1837 18               DEC R0
  1838 F2               MOVX @R0, A             ;       remote_wakeup = 0;
  1839 90FFC9           MOV DPTR, #0FFC9h
  183C E0               MOVX A, @DPTR
  183D 4480             ORL A, #80h
  183F F0               MOVX @DPTR, A           ;       UPCON.CONEN = true;
  1840 22               RET                     ;}

two_bits_set:                                   ;bool __register(C) two_bits_set() {
  1841 E4               CLR A
  1842 7853             MOV R0, #53h
  1844 F6               MOV @R0, A
  1845 7856             MOV R0, #56h
  1847 F6               MOV @R0, A              ;   v56 = 0;
L0220:                                          ;   for (byte __volatile(v53) i = 0; i < 8; ++i) {
  1848 7853             MOV R0, #53h
  184A E6               MOV A, @R0
  184B FF               MOV R7, A
  184C C3               CLR C
  184D 9408             SUBB A, #8h
  184F 5029             JNC L0216
  1851 7480             MOV A, #80h
  1853 7E00             MOV R6, #0h
  1855 C8               XCH A, R0
  1856 EF               MOV A, R7
  1857 C8               XCH A, R0
  1858 08               INC R0
  1859 8006             SJMP L0217

L0218:
  185B CE               XCH A, R6
  185C A2E7             MOV C, ACC.7
  185E 13               RRC A
  185F CE               XCH A, R6
  1860 13               RRC A
L0217:
  1861 D8F8             DJNZ R0, L0218

  1863 FF               MOV R7, A
  1864 7824             MOV R0, #24h
  1866 E6               MOV A, @R0
  1867 FD               MOV R5, A
  1868 EF               MOV A, R7
  1869 5D               ANL A, R5
  186A 6009             JZ L0219                ;       if (column_value & 0x80 >> i) {
  186C 7856             MOV R0, #56h
  186E 06               INC @R0                 ;           ++v56;
  186F E6               MOV A, @R0
  1870 B40202           CJNE A, #2h, L0219      ;           if (v56 == 2)
  1873 D3               SETB C
  1874 22               RET                     ;               return true;

L0219:                                          ;       }
  1875 7853             MOV R0, #53h
  1877 06               INC @R0
  1878 80CE             SJMP L0220              ;   }

L0216:
  187A C3               CLR C                   ;   return false;
  187B 22               RET                     ;}

                                                ;// Output into ports P1, P2, ANDed into P3 from read_column()
                                                ;static const byte matrix_mask[][3] = {
  187C FE               DB 0FEh
  187D FF               DB 0FFh
  187E FF               DB 0FFh
  187F FD               DB 0FDh
  1880 FF               DB 0FFh
  1881 FF               DB 0FFh
  1882 FB               DB 0FBh
  1883 FF               DB 0FFh
  1884 FF               DB 0FFh
  1885 F7               DB 0F7h
  1886 FF               DB 0FFh
  1887 FF               DB 0FFh
  1888 EF               DB 0EFh
  1889 FF               DB 0FFh
  188A FF               DB 0FFh
  188B DF               DB 0DFh
  188C FF               DB 0FFh
  188D FF               DB 0FFh
  188E BF               DB 0BFh
  188F FF               DB 0FFh
  1890 FF               DB 0FFh
  1891 7F               DB 07Fh
  1892 FF               DB 0FFh
  1893 FF               DB 0FFh
  1894 FF               DB 0FFh
  1895 FE               DB 0FEh
  1896 FF               DB 0FFh
  1897 FF               DB 0FFh
  1898 FD               DB 0FDh
  1899 FF               DB 0FFh
  189A FF               DB 0FFh
  189B FB               DB 0FBh
  189C FF               DB 0FFh
  189D FF               DB 0FFh
  189E F7               DB 0F7h
  189F FF               DB 0FFh
  18A0 FF               DB 0FFh
  18A1 EF               DB 0EFh
  18A2 FF               DB 0FFh
  18A3 FF               DB 0FFh
  18A4 DF               DB 0DFh
  18A5 FF               DB 0FFh
  18A6 FF               DB 0FFh
  18A7 BF               DB 0BFh
  18A8 FF               DB 0FFh
  18A9 FF               DB 0FFh
  18AA 7F               DB 07Fh
  18AB FF               DB 0FFh
  18AC FF               DB 0FFh
  18AD FF               DB 0FFh
  18AE F7               DB 0F7h
  18AF FF               DB 0FFh
  18B0 FF               DB 0FFh
  18B1 EF               DB 0EFh
  18B2 00               DB 000h
  18B3 00               DB 000h
  18B4 E7               DB 0E7h                 ;}

received_ep0:                                   ;void received_ep0() {
  18B5 7857             MOV R0, #57h
  18B7 74FE             MOV A, #0FEh
  18B9 F2               MOVX @R0, A             ;   transmit_addr_mode = XRAM_8;
  18BA 08               INC R0
  18BB 7400             MOV A, #0h
  18BD F2               MOVX @R0, A
  18BE 08               INC R0
  18BF 7417             MOV A, #17h
  18C1 F2               MOVX @R0, A             ;   to_transmit = &report;
  18C2 121088           LCALL do_receive        ;   do_receive();
  18C5 7816             MOV R0, #16h
  18C7 E2               MOVX A, @R0
  18C8 B4F020           CJNE A, #0F0h, L0250    ;   if (request_state != 0xF0) return;
  18CB E4               CLR A
  18CC 785C             MOV R0, #5Ch
  18CE F2               MOVX @R0, A
  18CF 08               INC R0
  18D0 F2               MOVX @R0, A             ;   tx_rx_count = 0;
  18D1 7817             MOV R0, #17h
  18D3 E2               MOVX A, @R0
  18D4 5460             ANL A, #60h
  18D6 24E0             ADD A, #0E0h
  18D8 6007             JZ L0251                ;   switch (request.bmRequestType & 0x60) { // Type
  18DA 2420             ADD A, #20h
  18DC 7006             JNZ L0252
  18DE 02114D           LJMP standard_request   ;   case 0: standard_request(); return; // Standard
L0251:
  18E1 021208           LJMP vendor_request     ;   case 0x20: vendor_request(); return; // Vendor
L0252:                                          ;   default:
  18E4 90FFE1           MOV DPTR, #0FFE1h
  18E7 E0               MOVX A, @DPTR
  18E8 44C0             ORL A, #0C0h
  18EA F0               MOVX @DPTR, A           ;       EPCON.RXSTL = EPCON.TXSTL = true;
L0250:
  18EB 22               RET                     ;       return;
                                                ;   }
                                                ;}

same_column_value:                              ;bool __register(C) same_column_value() {
  18EC 7823             MOV R0, #23h
  18EE E6               MOV A, @R0
  18EF 04               INC A
  18F0 FF               MOV R7, A
  18F1 7853             MOV R0, #53h
  18F3 F6               MOV @R0, A
  18F4 BF1202           CJNE R7, #12h, L0213
  18F7 E4               CLR A
  18F8 F6               MOV @R0, A
L0213:                                          ;   for (__volatile(v53) i = (column_index + 1) % sizeof(key_matrix); i != column_index; i = (i + 1) % sizeof(key_matrix)) { // Complicated expressions in pseudo-C; basically “roll over to 0 until original value”
  18F9 7853             MOV R0, #53h
  18FB E6               MOV A, @R0
  18FC FF               MOV R7, A
  18FD 7823             MOV R0, #23h
  18FF 66               XRL A, @R0
  1900 601A             JZ L0214
  1902 12169B           LCALL read_column
  1905 7856             MOV R0, #56h
  1907 EF               MOV A, R7
  1908 F6               MOV @R0, A              ;       v56 = read_column(v53);
  1909 7824             MOV R0, #24h
  190B E6               MOV A, @R0
  190C 6F               XRL A, R7
  190D 7002             JNZ L0215               ;       if (column_value == v56) {
  190F D3               SETB C                  ;           return true;
  1910 22               RET
L0215:                                          ;       }
  1911 7853             MOV R0, #53h
  1913 06               INC @R0
  1914 E6               MOV A, @R0
  1915 B412E1           CJNE A, #12h, L0213
  1918 E4               CLR A
  1919 F6               MOV @R0, A
  191A 80DD             SJMP L0213

L0214:                                          ;   }
  191C C3               CLR C                   ;   return false;
  191D 22               RET                     ;}

                                                ;// http://geekhack.org/index.php?topic=40888.0
                                                ;// addwyn: Truly Ergonomic Shift-F12-F12 locks the NumLock key...
process_shift_f12:                              ;void process_shift_f12() {
  191E 784B             MOV R0, #4Bh
  1920 E6               MOV A, @R0
  1921 FF               MOV R7, A
  1922 B40205           CJNE A, #2h, L0144      ;   if (key_modifiers != [LShift]
  1925 784E             MOV R0, #4Eh
  1927 E6               MOV A, @R0
  1928 6005             JZ L0145                ;       or keys_down[1] != 0)
L0144:                                          ;   {
  192A E4               CLR A
  192B 7822             MOV R0, #22h
  192D F6               MOV @R0, A              ;       shift_f12_count = 0;
  192E 22               RET                     ;       return;

L0145:                                          ;   }
  192F EF               MOV A, R7
  1930 B40217           CJNE A, #2h, L0146      ;   if (key_modifiers == [LShift]
  1933 784D             MOV R0, #4Dh
  1935 E6               MOV A, @R0
  1936 B44511           CJNE A, #45h, L0146     ;       and keys_down[0] == 0x45 // F12
  1939 7822             MOV R0, #22h
  193B 06               INC @R0
  193C E6               MOV A, @R0
  193D B4020A           CJNE A, #2h, L0146      ;       and ++shift_f12_count == 2)
  1940 18               DEC R0                  ;   {
  1941 E6               MOV A, @R0
  1942 F4               CPL A
  1943 F6               MOV @R0, A              ;       kb_mode = ~kb_mode;
  1944 E4               CLR A
  1945 08               INC R0
  1946 F6               MOV @R0, A              ;       shift_f12_count = 0;
  1947 121AB0           LCALL upd_leds          ;       upd_leds();
L0146:                                          ;   }
  194A 22               RET                     ;}

receive:                                        ;void receive(R3 == 1,    byte* __register(R2:R1) Xbase16, byte __register(R5) size)
                                                ;  or receive(R3 == 0,    byte* __register(R1)    base8,   byte __register(R5) size)
                                                ;  or receive(R3 == 0xFE, byte* __register(R1)    Xbase8,  byte __register(R5) size)
                                                ;{
  194B 7865             MOV R0, #65h
  194D EB               MOV A, R3
  194E F2               MOVX @R0, A             ;   X65 = mode;
  194F 08               INC R0
  1950 EA               MOV A, R2
  1951 F2               MOVX @R0, A
  1952 08               INC R0
  1953 E9               MOV A, R1
  1954 F2               MOVX @R0, A             ;   Xw66 = base;
  1955 E4               CLR A
  1956 FF               MOV R7, A
L0305:
  1957 EF               MOV A, R7
  1958 C3               CLR C
  1959 9D               SUBB A, R5
  195A 501B             JNC L0303               ;   for (byte __register(R7) i = 0; i < size; ++i) {
  195C 90FFE3           MOV DPTR, #0FFE3h
  195F E0               MOVX A, @DPTR
  1960 FE               MOV R6, A
  1961 7865             MOV R0, #65h
  1963 E2               MOVX A, @R0
  1964 FB               MOV R3, A
  1965 08               INC R0
  1966 E2               MOVX A, @R0
  1967 FA               MOV R2, A
  1968 08               INC R0
  1969 E2               MOVX A, @R0
  196A F9               MOV R1, A
  196B 8F82             MOV DPL, R7
  196D 758300           MOV DPH, #0h
  1970 EE               MOV A, R6
  1971 121004           LCALL memwrite          ;       memwrite(X65, Xw66, i, RXDAT);
  1974 0F               INC R7
  1975 80E0             SJMP L0305              ;   }

L0303:
  1977 22               RET                     ;}

transmit:                                       ;void transmit(byte __register(R3) mode, word __register(R2:R1) base, byte __register(R5) size) {
  1978 7865             MOV R0, #65h
  197A EB               MOV A, R3
  197B F2               MOVX @R0, A             ;   X65 = mode;
  197C 08               INC R0
  197D EA               MOV A, R2
  197E F2               MOVX @R0, A
  197F 08               INC R0
  1980 E9               MOV A, R1
  1981 F2               MOVX @R0, A             ;   Xw66 = base;

  1982 E4               CLR A
  1983 FF               MOV R7, A
L0274:
  1984 EF               MOV A, R7
  1985 C3               CLR C
  1986 9D               SUBB A, R5
  1987 5019             JNC L0272               ;   for (byte __register(R7) i = 0; i < size; ++i)
  1989 7865             MOV R0, #65h
  198B E2               MOVX A, @R0
  198C FB               MOV R3, A
  198D 08               INC R0
  198E E2               MOVX A, @R0
  198F FA               MOV R2, A
  1990 08               INC R0
  1991 E2               MOVX A, @R0
  1992 F9               MOV R1, A
  1993 8F82             MOV DPL, R7
  1995 758300           MOV DPH, #0h
  1998 120FD7           LCALL memread
  199B 90FFF3           MOV DPTR, #0FFF3h
  199E F0               MOVX @DPTR, A           ;       TXDAT = memread(mode, base, i);
  199F 0F               INC R7
  19A0 80E2             SJMP L0274              ;   }
L0272:
  19A2 22               RET                     ;}

isp:                                            ;byte __register(R7) isp(byte __register(R7) mode, byte __register(R5) data) {
  19A3 780D             MOV R0, #0Dh
  19A5 E2               MOVX A, @R0
  19A6 F5E3             MOV 0E3h, A
  19A8 08               INC R0
  19A9 E2               MOVX A, @R0
  19AA F5E4             MOV 0E4h, A             ;   IFADRH:IFADRL = Xw0D;
  19AC EF               MOV A, R7
  19AD B40205           CJNE A, #2h, L0292      ;   if (mode == 2)
  19B0 CE               XCH A, R6
  19B1 ED               MOV A, R5
  19B2 CE               XCH A, R6
  19B3 8EE2             MOV 0E2h, R6            ;       IFD = data;
L0292:                                          ;   }
  19B5 EF               MOV A, R7
  19B6 4480             ORL A, #80h
  19B8 F5E7             MOV 0E7h, A             ;   ISPCR = mode | ISPEN;
  19BA 75E646           MOV 0E6h, #46h          ;   SCMD = 0x46;
  19BD 75E6B9           MOV 0E6h, #0B9h         ;   SCMD = 0xB9;
  19C0 E4               CLR A
  19C1 F5E7             MOV 0E7h, A             ;   ISPCR = 0;
  19C3 EF               MOV A, R7               ;
  19C4 B40103           CJNE A, #1h, L0293      ;   if (mode == 1) {
  19C7 AFE2             MOV R7, 0E2h
  19C9 22               RET                     ;       return IFD;
L0293:                                          ;   }
  19CA 7F00             MOV R7, #0h             ;   return 0;
  19CC 22               RET                     ;}

do_delay:                                       ;void do_delay() {
  19CD 7804             MOV R0, #4h
  19CF E2               MOVX A, @R0
  19D0 FF               MOV R7, A
  19D1 7009             JNZ L0018               ;   if (numlock_timer == 0
  19D3 08               INC R0
  19D4 E2               MOVX A, @R0
  19D5 B48804           CJNE A, #88h, L0018     ;       and numlock_state == 0x88)
  19D8 74BB             MOV A, #0BBh            ;   {
  19DA F2               MOVX @R0, A             ;       numlock_state = 0xBB;
  19DB 22               RET                     ;       return;

L0018:                                          ;   }
  19DC EF               MOV A, R7
  19DD C3               CLR C
  19DE 9400             SUBB A, #0h
  19E0 400E             JC L0019                ;   if (numlock_timer >= 0 // always??
  19E2 7805             MOV R0, #5h
  19E4 E2               MOVX A, @R0
  19E5 B48808           CJNE A, #88h, L0019     ;       and numlock_state == 0x88)
  19E8 18               DEC R0                  ;   {
  19E9 E2               MOVX A, @R0
  19EA 14               DEC A
  19EB F2               MOVX @R0, A             ;       --numlock_timer;
  19EC 00               NOP
  19ED 121A99           LCALL micro_delay_750   ;       micro_delay_750();
L0019:                                          ;   }
  19F0 22               RET                     ;}

isp_erase_pages:                                ;void isp_erase_pages() {
  19F1 E4               CLR A
  19F2 7813             MOV R0, #13h
  19F4 F2               MOVX @R0, A
L0321:
  19F5 7812             MOV R0, #12h
  19F7 E2               MOVX A, @R0
  19F8 FF               MOV R7, A
  19F9 08               INC R0
  19FA E2               MOVX A, @R0
  19FB C3               CLR C
  19FC 9F               SUBB A, R7
  19FD 5014             JNC L0320               ;   for (byte __volatile(X13) i = 0; i < LOBYTE(isp_count); ++i) {
  19FF E4               CLR A
  1A00 FD               MOV R5, A
  1A01 7F03             MOV R7, #3h
  1A03 1219A3           LCALL isp               ;       isp(IspModePageErase);
  1A06 780D             MOV R0, #0Dh
  1A08 E2               MOVX A, @R0
  1A09 2402             ADD A, #2h
  1A0B F2               MOVX @R0, A             ;       isp_ptr += 0x200;
  1A0C 7813             MOV R0, #13h
  1A0E E2               MOVX A, @R0
  1A0F 04               INC A
  1A10 F2               MOVX @R0, A
  1A11 80E2             SJMP L0321              ;   }
L0320:
  1A13 22               RET                     ;}

DO_TIMER0:                                      ;void __interrupt timer0() {
  1A14 C0E0             PUSH ACC
  1A16 C0D0             PUSH PSW
  1A18 75D008           MOV PSW, #8h            ;   // use register bank 1
  1A1B 7801             MOV R0, #1h
  1A1D E2               MOVX A, @R0
  1A1E F5E1             MOV 0E1h, A             ;   WDTCR = wdtcr; // Watch-dog Timer
  1A20 C28C             CLR TR0
  1A22 18               DEC R0
  1A23 E2               MOVX A, @R0
  1A24 600B             JZ L0232                ;   if (delay_count != 0) {
  1A26 E2               MOVX A, @R0
  1A27 14               DEC A
  1A28 F2               MOVX @R0, A             ;       --delay_count;
  1A29 758A18           MOV TL0, #18h
  1A2C 758CFC           MOV TH0, #0FCh          ;       set_timer0(-1000);
  1A2F D28C             SETB TR0
L0232:                                          ;   }
  1A31 D0D0             POP PSW
  1A33 D0E0             POP ACC
  1A35 32               RETI                    ;}

set_interface:                                  ;void set_interface() {
  1A36 781B             MOV R0, #1Bh
  1A38 E2               MOVX A, @R0             ;   switch (LOBYTE(request.wIndex)) {
  1A39 14               DEC A
  1A3A 6003             JZ L0402                ;       // case 1
  1A3C 04               INC A
  1A3D 7010             JNZ L0403               ;   case 0:
L0402:                                          ;   case 1:
  1A3F 7819             MOV R0, #19h
  1A41 E2               MOVX A, @R0
  1A42 D3               SETB C
  1A43 9400             SUBB A, #0h
  1A45 4002             JC L0404                ;       if (LOBYTE(request.wValue) < 1) {
  1A47 8006             SJMP L0403
L0404:
  1A49 90FFF6           MOV DPTR, #0FFF6h
  1A4C E4               CLR A
  1A4D F0               MOVX @DPTR, A           ;           TXCNT = 0;
  1A4E 22               RET                     ;           return;

L0403:                                          ;       }
                                                ;       // fallthrough
                                                ;   default:
  1A4F 90FFE1           MOV DPTR, #0FFE1h
  1A52 E0               MOVX A, @DPTR
  1A53 44C0             ORL A, #0C0h
  1A55 F0               MOVX @DPTR, A           ;       EPCON.RXSTL = EPCON.TXSTL = 0;
  1A56 22               RET                     ;}  }

DO_USB:                                         ;void __interrupt usb_intr() {
  1A57 C0E0             PUSH ACC
  1A59 C0F0             PUSH B
  1A5B C083             PUSH DPH
  1A5D C082             PUSH DPL
  1A5F C0D0             PUSH PSW
  1A61 75D018           MOV PSW, #18h           ;   // use register bank 3
  1A64 7801             MOV R0, #1h
  1A66 E2               MOVX A, @R0
  1A67 F5E1             MOV 0E1h, A             ;   WDTCR = wdtcr; // Watch-dog timer
  1A69 120960           LCALL DO_USB_2          ;   do_usb_2();
  1A6C D0D0             POP PSW
  1A6E D082             POP DPL
  1A70 D083             POP DPH
  1A72 D0F0             POP B
  1A74 D0E0             POP ACC
  1A76 32               RETI                    ;}

get_interface:                                  ;void get_interface() {
  1A77 785C             MOV R0, #5Ch
  1A79 E4               CLR A
  1A7A F2               MOVX @R0, A
  1A7B 08               INC R0
  1A7C 04               INC A
  1A7D F2               MOVX @R0, A             ;   tx_rx_count = 1;
  1A7E 781B             MOV R0, #1Bh
  1A80 E2               MOVX A, @R0             ;   switch (LOBYTE(request.wIndex)) {
  1A81 14               DEC A
  1A82 6003             JZ L0398                ;       // case 1
  1A84 04               INC A
  1A85 7005             JNZ L0399               ;   case 0: // default over
L0398:                                          ;   case 1:
  1A87 E4               CLR A
  1A88 7817             MOV R0, #17h
  1A8A F2               MOVX @R0, A             ;       report[0] = 0;
  1A8B 22               RET                     ;       return;

L0399:                                          ;   default:
  1A8C 90FFE1           MOV DPTR, #0FFE1h
  1A8F E0               MOVX A, @DPTR
  1A90 44C0             ORL A, #0C0h
  1A92 F0               MOVX @DPTR, A           ;   EPCON.RXSTL = EPCON.TXSTL = 0;
  1A93 22               RET                     ;}  }

micro_delay_1000:                               ;void micro_delay_1000() {…}
  1A94 7FFA             MOV R7, #0FAh
  1A96 121AA5           LCALL micro_delay
micro_delay_750:                                ;void micro_delay_750() {…}
  1A99 7FFA             MOV R7, #0FAh
  1A9B 121AA5           LCALL micro_delay
micro_delay_500:                                ;void micro_delay_500() {
  1A9E 7FFA             MOV R7, #0FAh
  1AA0 121AA5           LCALL micro_delay       ;   micro_delay(250);
  1AA3 7FFA             MOV R7, #0FAh           ;   micro_delay(250);
                                                ;}
micro_delay:                                    ;void micro_delay(byte __register(R7) iters) {
  1AA5 EF               MOV A, R7               ;   for (; iters >= 1; --iters) { // 1 clock
  1AA6 D3               SETB C                  ;                                 // 1 clock
  1AA7 9400             SUBB A, #0h             ;                                 // 2 clocks
  1AA9 4004             JC L0017                ;                                 // 3 clocks
  1AAB 00               NOP                     ;                                 // 1 clock
  1AAC 1F               DEC R7                  ;                                 // 3 clock
  1AAD 80F6             SJMP micro_delay        ;   }                             // 3 clocks, total 14 = 1.1(6) microseconds per iter
L0017:
  1AAF 22               RET                     ;}

upd_leds:                                       ;void upd_leds() {
  1AB0 A201             MOV C, 1h
  1AB2 B3               CPL C
  1AB3 92B6             MOV P3.6, C             ;   P3./CAPS = !led_state.CAPS;
  1AB5 A202             MOV C, 2h
  1AB7 B3               CPL C
  1AB8 92B7             MOV P3.7, C             ;   P3./SCROLL = !led_state.SCROLL;
  1ABA 7821             MOV R0, #21h
  1ABC E6               MOV A, @R0
  1ABD B45A03           CJNE A, #5Ah, L0148     ;   if (kb_mode == 0x5A) {
  1AC0 D2E8             SETB 0E8h               ;       P4.0 = true;
  1AC2 22               RET                     ;   } else {
L0148:
  1AC3 C2E8             CLR 0E8h                ;       P4.0 = false;
  1AC5 22               RET                     ;}  }

init_isp:                                       ;void init_isp() {
  1AC6 E4               CLR A
  1AC7 780A             MOV R0, #0Ah
  1AC9 F2               MOVX @R0, A             ;   isp_state = 0;
  1ACA 08               INC R0
  1ACB 121043           LCALL mov_dword         ;   isp_ptr = 0; // mov_dword(&isp_ptr);
  1ACE 00               NOP
  1ACF 00               NOP
  1AD0 00               NOP
  1AD1 00               NOP
  1AD2 780F             MOV R0, #0Fh
  1AD4 121043           LCALL mov_dword         ;   isp_count = 0; // mov_dword(&isp_count);
  1AD7 00               NOP
  1AD8 00               NOP
  1AD9 00               NOP
  1ADA 00               NOP
  1ADB 22               RET                     ;}

delay:                                          ;void delay(byte __register(R7) ms) {
  1ADC C28C             CLR TR0
  1ADE 7800             MOV R0, #0h
  1AE0 EF               MOV A, R7
  1AE1 F2               MOVX @R0, A             ;   delay_count = param;
  1AE2 758A18           MOV TL0, #18h
  1AE5 758CFC           MOV TH0, #0FCh          ;   set_timer0(-1000);
  1AE8 D28C             SETB TR0
L0230:                                          ;   do {
  1AEA 7800             MOV R0, #0h
  1AEC E2               MOVX A, @R0
  1AED 70FB             JNZ L0230               ;   } while (delay_count != 0);
  1AEF 22               RET                     ;}

real_start:                                     ;void real_start() {
  1AF0 12006E           LCALL init_all          ;   init_all();
L0009:                                          ;   for (;;) {
  1AF3 12157B           LCALL scan_column       ;       scan_column();
  1AF6 12007E           LCALL process_key       ;       process_key();
  1AF9 1219CD           LCALL do_delay          ;       do_delay();
  1AFC 121477           LCALL numlock_off       ;       numlock_off();
  1AFF 80F2             SJMP L0009              ;}  }

trigger_numlock:                                ;void trigger_numlock() {
  1B01 7805             MOV R0, #5h
  1B03 E2               MOVX A, @R0
  1B04 700B             JNZ L0176               ;   if (numlock_state == 0
  1B06 783E             MOV R0, #3Eh
  1B08 E6               MOV A, @R0
  1B09 B40105           CJNE A, #1h, L0176      ;       and normal_key)
  1B0C 7805             MOV R0, #5h             ;   {
  1B0E 74EA             MOV A, #0EAh
  1B10 F2               MOVX @R0, A             ;       numlock_state = 0xEA;
L0176:                                          ;   }
  1B11 22               RET                     ;}

L0152:                                          ;byte __register(R7) f0152() {
  1B12 121841           LCALL two_bits_set
  1B15 5008             JNC L0211               ;   if (not two_bits_set()) return 0;
  1B17 1218EC           LCALL same_column_value
  1B1A 5003             JNC L0211               ;   if (not same_column_value()) return 0;
  1B1C 7F00             MOV R7, #0h
  1B1E 22               RET                     ;   return 0;

L0211:
  1B1F 7F00             MOV R7, #0h
  1B21 22               RET                     ;}

usb_transmit:                                   ;usb_transmit(byte __register(A) endpoint) {
  1B22 90FFF1           MOV DPTR, #0FFF1h
  1B25 F0               MOVX @DPTR, A           ;   EPINDEX = endpoint;
  1B26 7F10             MOV R7, #10h
  1B28 90FFF4           MOV DPTR, #0FFF4h
  1B2B E0               MOVX A, @DPTR
  1B2C 540F             ANL A, #0Fh
  1B2E 4F               ORL A, R7
  1B2F F0               MOVX @DPTR, A           ;   TXCON &= 0x0F |= 0x10; // TXCON.TXFFRC = true
  1B30 22               RET                     ;}

START:
  1B31 78FF             MOV R0, #0FFh
  1B33 E4               CLR A
L0002:                                          ;for (byte* __register(R0) ptr = 0xFF; ptr --> 0 ;){
  1B34 F6               MOV @R0, A              ;   *ptr = 0;
  1B35 D8FD             DJNZ R0, L0002          ;}
  1B37 75815A           MOV SP, #5Ah
  1B3A 021AF0           LJMP real_start

leds_off:                                       ;void leds_off() {
  1B3D D2B5             SETB P3.5               ;   P3./NUM = true;
  1B3F D2B6             SETB P3.6               ;   P3./CAPS = true;
  1B41 D2B7             SETB P3.7               ;   P3./SCROLL = true;
  1B43 D2E8             SETB 0E8h               ;   P4.0 = true;
  1B45 22               RET                     ;}

main_keycodes:                                  ;static const __code byte main_keycodes[16][144] = {
  1B46 00004C00002B3500
  1B4E 0000000000000000
  1B56 041F2D641E343300
  1B5E E600392C00E1E500
  1B66 004F002C52000000
  1B6E E20000DE000000E4
  1B76 0000000000E3E700
  1B7E 00000000DFE00000
  1B86 0000000000000000
  1B8E 363A4E3B4B291412
  1B96 003C4C3D00000000
  1B9E 0820372506171A0D
  1BA6 0C211C2213181B0E
  1BAE 0B230A2409071005
  1BB6 2F3E283F2A312A50
  1BBE 38402E4126151911
  1BC6 1D42514327160F30
  1BCE 00444D454A000000

  1BD6 00004C00002B3500
  1BDE 0000000000000000
  1BE6 041F2D641E343300
  1BEE E400392C00E1E500
  1BF6 004F002C52000000
  1BFE E20000DE000000E6
  1C06 0000000000E3E700
  1C0E 00000000DFE00000
  1C16 0000000000000000
  1C1E 363A4E3B4B291412
  1C26 003C4C3D00000000
  1C2E 0820372506171A0D
  1C36 0C211C2213181B0E
  1C3E 0B230A2409071005
  1C46 2F3E283F2A312A50
  1C4E 38402E4126151911
  1C56 1D42514327160F30
  1C5E 00444D454A000000

  1C66 00004C00002B3500
  1C6E 0000000000000000
  1C76 041F38641E141D00
  1C7E E600392C00E1E500
  1C86 004F002C52000000
  1C8E E20000DE000000E4
  1C96 0000000000E3E700
  1C9E 00000000DFE00000
  1CA6 0000000000000000
  1CAE 1A3A4E3B4B291B16
  1CB6 003C4C3D00000000
  1CBE 072008250C0E3606
  1CC6 0A21172215090519
  1CCE 0D2318241C0B1011
  1CD6 313E283F2A2D2A50
  1CDE 2F402E412612370F
  1CE6 3442514327331330
  1CEE 00444D454A000000

  1CF6 00004C00002B3500
  1CFE 0000000000000000
  1D06 041F2D641E141D00
  1D0E E400392C00E1E500
  1D16 004F002C52000000
  1D1E E20000DE000000E6
  1D26 0000000000E3E700
  1D2E 00000000DFE00000
  1D36 0000000000000000
  1D3E 1A3A4E3B4B291B16
  1D46 003C4C3D00000000
  1D4E 072008250C0E3606
  1D56 0A21172215090519
  1D5E 0D2318241C0B1011
  1D66 2F3E283F2A312A50
  1D6E 34402E412612370F
  1D76 3842514327331330
  1D7E 00444D454A000000

  1D86 00004C00002B3500
  1D8E 0000000000000000
  1D96 041F2D641E141D00
  1D9E E600392C00E1E500
  1DA6 004F002C52000000
  1DAE E20000DE000000E4
  1DB6 0000000000E3E700
  1DBE 00000000DFE00000
  1DC6 0000000000000000
  1DCE 1A3A4E3B4B291B16
  1DD6 003C4C3D00000000
  1DDE 072008250C0E3606
  1DE6 0A21172215090519
  1DEE 0D2318241C0B1011
  1DF6 2F3E283F2A312A50
  1DFE 34402E412612370F
  1E06 3842514327331330
  1E0E 00444D454A000000

  1E16 00004C00002B3500
  1E1E 0000000000000000
  1E26 041F38641E141D00
  1E2E E400392C00E1E500
  1E36 004F002C52000000
  1E3E E20000DE000000E6
  1E46 0000000000E3E700
  1E4E 00000000DFE00000
  1E56 0000000000000000
  1E5E 1A3A4E3B4B291B16
  1E66 003C4C3D00000000
  1E6E 072008250C0E3606
  1E76 0A21172215090519
  1E7E 0D2318241C0B1011
  1E86 313E283F2A2D2A50
  1E8E 2F402E412612370F
  1E96 3442514327331330
  1E9E 00444D454A000000

  1EA6 00008A00002B3500
  1EAE 0000000000000000
  1EB6 041F2D891E141D00
  1EBE 8700392C00E1E500
  1EC6 004F002C52000000
  1ECE E20000DE000000E4
  1ED6 0000000000E3E700
  1EDE 00000000DF880000
  1EE6 0000000000000000
  1EEE 1A3A4E3B4B291B16
  1EF6 003C4C3D00000000
  1EFE 072008250C0E3606
  1F06 0A21172215090519
  1F0E 0D2318241C0B1011
  1F16 2F3E283F2A312A50
  1F1E 34402E412612370F
  1F26 3842514327331330
  1F2E 00444D454A000000

  1F36 00004C00002B3500
  1F3E 0000000000000000
  1F46 041F2D641E141D00
  1F4E E400392C00E1E500
  1F56 004F002C52000000
  1F5E E20000DE000000E6
  1F66 0000000000E3E700
  1F6E 00000000DFE00000
  1F76 0000000000000000
  1F7E 1A3A4E3B4B291B16
  1F86 003C4C3D00000000
  1F8E 072008250C0E3606
  1F96 0A21172215090519
  1F9E 0D2318241C0B1011
  1FA6 2F3E283F2A312A50
  1FAE 34402E412612370F
  1FB6 3842514327331330
  1FBE 00444D454A000000

  1FC6 00004C00002B3500
  1FCE 0000000000000000
  1FD6 041F34E31E141D00
  1FDE 6500392C00E0E400
  1FE6 004F002C52000000
  1FEE E20000DE000000E6
  1FF6 0000000000E1E500
  1FFE 00000000DFE30000
  2006 0000000000000000
  200E 1A3A4E3B4B291B16
  2016 003C4C3D00000000
  201E 072008250C0E3606
  2026 0A21172215090519
  202E 0D2318241C0B1011
  2036 2D3E283F64312A50
  203E 2F4030412612370F
  2046 384251432733132E
  204E 00444D454A000000

  2056 00004C00002B3500
  205E 0000000000000000
  2066 041F2DE31E343300
  206E 6500392C00E1E500
  2076 004F002C52000000
  207E E20000DE000000E6
  2086 0000000000E0E400
  208E 00000000DFE30000
  2096 0000000000000000
  209E 363A4E3B4B291412
  20A6 003C4C3D00000000
  20AE 0820372506171A0D
  20B6 0C211C2213181B0E
  20BE 0B230A2409071005
  20C6 2F3E283F64312A50
  20CE 38402E4126151911
  20D6 1D42514327160F30
  20DE 00444D454A000000

  20E6 00004C00002B3500
  20EE 0000000000000000
  20F6 041F34E31E141D00
  20FE 6500392C00E1E500
  2106 004F002C52000000
  210E E20000DE000000E6
  2116 0000000000E0E400
  211E 00000000DFE30000
  2126 0000000000000000
  212E 1A3A4E3B4B291B16
  2136 003C4C3D00000000
  213E 072008250C0E3606
  2146 0A21172215090519
  214E 0D2318241C0B1011
  2156 2D3E283F64312A50
  215E 2F4030412612370F
  2166 384251432733132E
  216E 00444D454A000000

  2176 00004C00002B3500
  217E 0000000000000000
  2186 041F2DE31E141D00
  218E 6500392C00E1E500
  2196 004F002C52000000
  219E E20000DE000000E6
  21A6 0000000000E0E400
  21AE 00000000DFE30000
  21B6 0000000000000000
  21BE 1A3A4E3B4B291B16
  21C6 003C4C3D00000000
  21CE 072008250C0E3606
  21D6 0A21172215090519
  21DE 0D2318241C0B1011
  21E6 2F3E283F64312A50
  21EE 34402E412612370F
  21F6 3842514327331330
  21FE 00444D454A000000

  2206 00004C00002B3500
  220E 0000000000000000
  2216 041F2DE31E141D00
  221E 6500392C00E0E400
  2226 004F002C52000000
  222E E20000DE000000E6
  2236 0000000000E1E500
  223E 00000000DFE30000
  2246 0000000000000000
  224E 1A3A4E3B4B291B16
  2256 003C4C3D00000000
  225E 072008250C0E3606
  2266 0A21172215090519
  226E 0D2318241C0B1011
  2276 2F3E283F2A312A50
  227E 34402E412612370F
  2286 3842514327331330
  228E 00444D454A000000

  2296 00004C00002B3500
  229E 0000000000000000
  22A6 041F38E31E141D00
  22AE 6500392C00E1E500
  22B6 004F002C52000000
  22BE E20000DE000000E6
  22C6 0000000000E0E400
  22CE 00000000DFE30000
  22D6 0000000000000000
  22DE 1A3A4E3B4B291B16
  22E6 003C4C3D00000000
  22EE 072008250C0E3606
  22F6 0A21172215090519
  22FE 0D2318241C0B1011
  2306 313E283F642D2A50
  230E 2F402E412612370F
  2316 3442514327331330
  231E 00444D454A000000

  2326 00008A00002B3500
  232E 0000000000000000
  2336 041F2DE31E141D00
  233E 8700392C00E1E500
  2346 004F002C52000000
  234E E20000DE000000E6
  2356 0000000000E0E400
  235E 00000000DF880000
  2366 0000000000000000
  236E 1A3A4E3B4B291B16
  2376 003C4C3D00000000
  237E 072008250C0E3606
  2386 0A21172215090519
  238E 0D2318241C0B1011
  2396 2F3E283F89312A50
  239E 34402E412612370F
  23A6 3842514327331330
  23AE 00444D454A000000

  23B6 00004C00002B3500
  23BE 0000000000000000
  23C6 041F2DE31E141D00
  23CE 6500392C00E1E500
  23D6 004F002C52000000
  23DE E20000DE000000E6
  23E6 0000000000E0E400
  23EE 00000000DFE30000
  23F6 0000000000000000
  23FE 1A3A4E3B4B291B16
  2406 003C4C3D00000000
  240E 072008250C0E3606
  2416 0A21172215090519
  241E 0D2318241C0B1011
  2426 2F3E283F2A312A50
  242E 34402E412612370F
  2436 3842514327331330
  243E 00444D454A000000

END
